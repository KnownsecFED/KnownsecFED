webpackJsonp([23445383189946],{620:function(e,n){e.exports={data:{site:{siteMetadata:{title:"创宇前端 - 最酷开发者的技术分享",author:"KnownsecFED",siteUrl:"https://knownsec-fed.com"}},markdownRemark:{id:"/tmp/app/src/pages/2018-03-16-yuan-chuang-ji-yu-babylonjs-shi-xian-3d-da-ji-xiao-guo/index.md absPath of file >>> MarkdownRemark",html:'<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/header-7428e1187e1c65f1b1900d9047e2bace-d6978.jpeg"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 1200px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMCBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHr12IrE//EABkQAQACAwAAAAAAAAAAAAAAAAIAEQESIP/aAAgBAQABBQIp3eZsuP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABkQAAIDAQAAAAAAAAAAAAAAAAAyAQISIP/aAAgBAQAGPwKdVFE4/8QAGhAAAgIDAAAAAAAAAAAAAAAAAAERISAxUf/aAAgBAQABPyF+lS0LsHNTRh//2gAMAwEAAgADAAAAEDP/AP/EABcRAQADAAAAAAAAAAAAAAAAAAABEVH/2gAIAQMBAT8QVOv/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPxBX/8QAGxAAAgIDAQAAAAAAAAAAAAAAAREAMSAhQYH/2gAIAQEAAT8Q3olJZhfH0QcmeC7w/9k=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="[原创] 基于 Babylon.js 实现 3D 打击效果"\n        title=""\n        src="/static/header-7428e1187e1c65f1b1900d9047e2bace-d6978.jpeg"\n        srcset="/static/header-7428e1187e1c65f1b1900d9047e2bace-527f0.jpeg 300w,\n/static/header-7428e1187e1c65f1b1900d9047e2bace-9a7cd.jpeg 600w,\n/static/header-7428e1187e1c65f1b1900d9047e2bace-d6978.jpeg 1200w"\n        sizes="(max-width: 1200px) 100vw, 1200px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h1>基于 Babylon.js 的 3D 打击效果实现</h1>\n<h3>先上效果图</h3>\n<p><img src="/attack-map-8dd3907c92e6105de547d4ef883dbf60.gif"></p>\n<p>是不是觉得很有意思, 那么就跟随我一起来实现吧!</p>\n<h2>准备工作</h2>\n<table>\n<thead>\n<tr>\n<th align="center">package</th>\n<th align="center">V</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">babylon</td>\n<td align="center">3.1.0</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>\n<p>前往 <a href="http://www.babylonjs.com/">Babylon.js</a> 官网下载 Babylon.js.</p>\n</li>\n<li>\n<p>准备一个 HTML 页面, 将下载好的 <code>Babylon.js</code> 通过 <code>script</code> 标签引入.</p>\n</li>\n<li>\n<p>在这个空白的 HTML 页面中放置一个 <code>canvas</code>, 让这个 <code>canvas</code> 占满屏幕</p>\n</li>\n</ol>\n<h2>文件结构</h2>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>.\n|____images             -> 图片资源\n| |____attackMap.gif    -> 组件运行效果截图\n|____data.json          -> 组件默认数据源\n|____lib.js             -> 基于 Babylon.js 实现的类\n|____index.js           -> 组件入口文件\n|____style.css          -> React 组件的 CSS 样式\n|____utils.js           -> 工具方法\n|____videoTexture.js    -> 波纹视频材质</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>images/red.png          -> 默认红色攻击线条贴图\nimages/green.png        -> 默认绿色攻击线条贴图\nimages/blue.png         -> 默认蓝色攻击线条贴图\nimages/ring_blue.png    -> 默认红色攻击波纹贴图\nimages/ring_blue.png    -> 默认红色攻击波纹贴图\nimages/ring_blue.png    -> 默认红色攻击波纹贴图</code></pre>\n      </div>\n<h2>科普一下</h2>\n<ul>\n<li>3D 打击效果实质上就是一条线在一条抛物线轨迹上运动的过程，且这条抛物线轨迹是由两个已知并且处在同一平面（X 轴和 z 轴）上。这条抛物线的高度（y 轴）是随机确定, 这样处理可以让攻击源和目标点之间多次攻击的抛物线在不同高度显示。</li>\n</ul>\n<h2>模拟数据</h2>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>[\n    {\n        "from": {\n            "x": 61.66897643728131,\n            "y": 0,\n            "z": 57.218511027229994\n        },\n        "to": {\n            "x": 22.638902093327285,\n            "y": 0,\n            "z": 88.63784341676953\n        },\n        "texture": "green",\n        "attack_power": 18,\n        "data": {}\n    },\n    {\n        "from": {\n            "x": 17.25975278621781,\n            "y": 0,\n            "z": 34.859315533740556\n        },\n        "to": {\n            "x": 85.73410306095155,\n            "y": 0,\n            "z": 43.63666854877888\n        },\n        "texture": "green",\n        "attack_power": 14,\n        "data": {}\n    },\n    ...\n]</code></pre>\n      </div>\n<h2>打击路径 (抛物线的构造)</h2>\n<p>我们将这条抛物线进行分解, 由于抛物线对称的特性, 我们就可以通过计算 <code>后半段的平抛运动</code> 的坐标点数组, 再通过 <code>对称</code>, 就可以求出前半段运动的坐标. 在 <code>x-z 轴平面</code> 上, 运动可以拆解为 <code>x 轴的匀速运动</code> 和 <code>z 轴的匀速运动</code>. 来看算法:</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>/**\n * 抛物线方程（计算路线）\n * data：攻击起点和终点坐标对象数组\n * avg：点之间的间距\n */\nexport const parabola = (data, avg) => {\n  const routes = data.map(ele => {\n    const temp = ele;\n    // 制作一个 Y-xz 坐标系，x=(Math.abs(x0-x1)^2+Math.abs(z0-z1)^2)^1/2\n    // xz 方向的长度\n    const xz =\n      (Math.abs(temp.to.x - temp.from.x) ** 2 +\n        Math.abs(temp.to.z - temp.from.z) ** 2) **\n      (1 / 2);\n    // 对应的 sin,cos 和 tan\n    const cos = Math.abs(temp.to.x - temp.from.x) / xz;\n    const sin = Math.abs(temp.to.z - temp.from.z) / xz;\n    const tan = (temp.to.z - temp.from.z) / (temp.to.x - temp.from.x);\n    // 设置点距（速度）\n    const speeds = xz * 1 / avg;\n    // 定义抛物线的坐标数组, 并将起点坐标存入\n    const XYarray = [];\n    // 确定顶点, 一个随机高度\n    const mPointY = Math.random() * (xz / 2 - 1) + 1;</code></pre>\n      </div>\n<p>有人可能会问, 为什么要求三角函数 <code>sin</code>,<code>cos</code>,<code>tan</code>? 这里主要的目的是为了求出在 <code>x-z 轴</code> 上运动的长度投影到 <code>x 轴</code> 和 <code>z 轴</code> 上分别对应的 <code>x 轴</code> 坐标值和 <code>z 轴</code> 坐标值.</p>\n<h4>接下来我们要算出 <code>后半段平抛运动竖直方向的加速度g</code></h4>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>// 得出 g, 平抛运动竖直方向的加速度\n    const g = 2 * mPointY / (avg / 2) ** 2;\n    // 应为抛物路线是对称的，所以先求出后半段的 Y 轴坐标数组\n    const Y = [];\n    for (let i = 0; i <= avg / 2; i++) {\n      Y.push(mPointY - g * i * i * (1 / 2));\n    }\n    // 定义点的坐标\n    let x = 0;\n    let z = 0;\n    for (let i = 0; i <= avg; i++) {\n      const index = i <= avg / 2 ? avg / 2 - i : i - avg / 2;\n      if (tan> 0) {\n        if (temp.from.z < temp.to.z) {\n          x = temp.from.x + i * speeds * cos;\n          z = temp.from.z + i * speeds * sin;\n        } else {\n          x = temp.from.x - i * speeds * cos;\n          z = temp.from.z - i * speeds * sin;\n        }\n      } else if (temp.from.z> temp.to.z) {\n        x = temp.from.x + i * speeds * cos;\n        z = temp.from.z - i * speeds * sin;\n      } else {\n        x = temp.from.x - i * speeds * cos;\n        z = temp.from.z + i * speeds * sin;\n      }\n      const temps = new BABYLON.Vector3(x, Y[index], z);\n      XYarray.push(temps);\n    }\n    return XYarray;\n  });\n  return routes;\n};</code></pre>\n      </div>\n<p>有了路径之后, 就要有一条线在这条轨迹上运动:</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>/**\n * 打击线条构造器\n * scene：容器\n * data：源数据\n * matList：材质\n */\nexport const createLine = (scene, data, matList) => {\n  const lineArray = data.map((item, index) => {\n    // 初始化线条在3D空间中连线的点\n    const point = new Array(LINE_LENGTH).fill(\n      new BABYLON.Vector3(item.from.x, item.from.y, item.from.z)\n    );\n    // 根据连线的点来创建这条线条\n    const line = BABYLON.MeshBuilder.CreateTube(\n      randomId(\'line\'),\n      {path: point, radius: 0.1, updatable: true},\n      scene\n    );\n    // 为线条贴上纹理\n    line.material = matList[index];\n    line.pointArray = point;\n    // 创建波纹平面\n    const plane = createPlane(\n      scene,\n      item.texture,\n      item.attack_power,\n      new BABYLON.Vector3(item.to.x, item.to.y, item.to.z)\n    );\n    line.plane = plane;\n    line.plane.isVisible = false;\n    return line;\n  });\n\n  return lineArray;\n};</code></pre>\n      </div>\n<p>创建线条的纹理贴图:</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>/**\n * 线条材质列表\n * scene：容器\n * data：源数据\n */\nconst creatMatList = (scene, data) => {\n  const colorGenerator = {\n    red: \'red\',\n    green: \'green\',\n    blue: \'blue\',\n  };\n  const matList = [];\n  data.forEach(item => {\n    const myMaterial = new BABYLON.StandardMaterial(randomId(\'myMat\'), scene);\n    const texture = item.texture;\n    const color = colorGenerator[texture];\n    myMaterial.diffuseTexture = new BABYLON.Texture(\n      `/models/images/${color}.png`,\n      scene\n    );\n    myMaterial.diffuseTexture.hasAlpha = true;\n    myMaterial.emissiveTexture = myMaterial.diffuseTexture;\n    matList.push(myMaterial);\n  });\n  return matList;\n};</code></pre>\n      </div>\n<p>光是一条线移动是看不出打击效果的, 故我们还要加上一个打击产生波纹的效果:</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>/**\n * 波纹构造器\n * scene：容器\n * data：数据源\n * power：大小\n * position：位置\n */\nconst createPlane = (scene, texture, power, positon) => {\n  const videoMat = getVideoTexture(scene, \'meteor\', texture);\n  const mat = new BABYLON.StandardMaterial(randomId(\'mat\'), scene);\n  mat.diffuseTexture = videoMat;\n  mat.diffuseColor = new BABYLON.Color3(0, 0, 0);\n  mat.diffuseTexture.hasAlpha = true;\n  mat.emissiveTexture = mat.diffuseTexture;\n  mat.backFaceCulling = false;\n  mat.alpha = 0.8;\n  const plane = BABYLON.MeshBuilder.CreatePlane(\n    randomId(\'plane\'),\n    {size: power},\n    scene\n  );\n  plane.material = mat;\n  plane.rotation.x = 90 * Math.PI / 180;\n  plane.position = positon;\n  return plane;\n};</code></pre>\n      </div>\n<p>这里为了优化, 波纹的纹理材质是一个视频, 所以要创建一个视频的贴图 (videoTexture.js 在这个文件中):</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>const TEXTURE_COLORS = [\'red\', \'green\', \'blue\'];\nconst videoTexture = {\n  meteor: {},\n};\n\nclass SourceException {\n  constructor(message) {\n    this.message = message;\n    this.name = \'SourceException\';\n  }\n}\n\n// 获取视频材质\nexport const getVideoTexture = (scene, type, color) => {\n  if (!videoTexture[type]) {\n    throw new SourceException(\n      `Error: the video texture of \'${type}_${color}\' does not exist.`\n    );\n  }\n\n  videoTexture[type][color] =\n    videoTexture[type][color] ||\n    new BABYLON.VideoTexture(\n      `videoTexture_${type}_${color}`,\n      [`models/${type}/${type}_${color}.mp4`],\n      scene,\n      true,\n      false\n    );\n  return videoTexture[type][color];\n};\n\n// 播放视频\nexport const onScenePointerUp = scene => {\n  Object.keys(videoTexture).forEach(type => {\n    TEXTURE_COLORS.forEach(color => {\n      getVideoTexture(scene, type, color).video.play();\n    });\n  });\n};</code></pre>\n      </div>\n<p>为了让攻击线条能够以圆滑的方式进场和出场, 所以还要对线条进行一点处理:</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>/**\n * 线条数据更新\n * counter：计数器\n * path：移动路线\n * tempArrary：进入平面和移出平面时的线条长度\n */\nconst setLinePath = (counter, path, tempArrary) => {\n  const temp = tempArrary;\n  const head = counter % path.length;\n  const tail = (counter - LINE_LENGTH + 1) % path.length;\n\n  // 线条在凋零时\n  if (tail> path.length - LINE_LENGTH) {\n    temp.splice(head, 1, path[path.length - 1]);\n    return temp;\n  }\n  const curPoints = path.slice(tail, head + 1);\n\n  return curPoints;\n};</code></pre>\n      </div>\n<p>所有的演员已就绪, 现在开始表演:</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>/**\n * 攻击线条更新\n * scene：容器\n * data：数据源\n * routes：移动路线数组\n * alpha：计数器数组\n */\nexport const updataLine = (scene, data, routes, alpha) => {\n  let counter = alpha;\n  const matList = creatMatList(scene, data);\n  const lineArray = createLine(scene, data, matList);\n\n  // 这里调用Babylon.js内置的一个实现动画的方法\n  const anim = scene.onBeforeRenderObservable.add(() => {\n    lineArray.forEach((ele, index) => {\n      let temp = ele;\n      const head = counter % routes[index].length;\n      const tail = (counter - LINE_LENGTH + 1) % routes[index].length;\n      temp.pointArray = setLinePath(counter, routes[index], temp.pointArray);\n      // 这里利用Babylon.js中物体自身刷新重载的方法,让物体在自身上进行新的位置刷新,而不是重新构造一个新的物体.这样就可以提高运行的效率\n      temp = BABYLON.MeshBuilder.CreateTube(\n        randomId(\'line\'),\n        {path: temp.pointArray, radius: 0.1, updatable: true, instance: temp},\n        scene\n      );\n      temp.material = matList[index];\n      // 当线条头部分接触平面后,显示波纹,\n      if (head === 100) {\n        temp.plane.isVisible = true;\n        onScenePointerUp(scene);\n      }\n      // 当线条尾巴部分离开平面后,打击动画停止\n      if (tail === 100) {\n        temp.plane.isVisible = false;\n        temp.plane.dispose();\n        temp.dispose();\n        scene.onBeforeRenderObservable.remove(anim);\n      }\n    });\n    counter += 1;\n  });\n};</code></pre>\n      </div>\n<p>演员演得再好, 没有一个好的舞台背景怎么行呢:</p>\n<p>摄像机来:</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>_initCameras = (scene, canvas) => {\n    const camera = new BABYLON.ArcRotateCamera(\n      \'MainCamera\',\n      5,\n      10,\n      10,\n      BABYLON.Vector3(0, 10, 0),\n      scene\n    );\n    camera.lowerBetaLimit = 0.1;\n    camera.upperBetaLimit = Math.PI / 2 * 0.99;\n    camera.lowerRadiusLimit = 150;\n    camera.attachControl(canvas, true);\n    return camera;\n  };</code></pre>\n      </div>\n<p>灯光来:</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>_initLights = scene => {\n    const pointLight = new BABYLON.HemisphericLight(\n      \'pointLight\',\n      new BABYLON.Vector3(1, 1, 0),\n      scene\n    );\n    pointLight.intensity = 0.06;\n    return pointLight;\n  };</code></pre>\n      </div>\n<p>背景来:</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code> _initGround = screen => {\n    const ground = BABYLON.MeshBuilder.CreateGround(\n      \'ground\',\n      {\n        width: 400,\n        height: 400,\n      },\n      screen\n    );\n    ground.diffuseColor = new BABYLON.Color3(0, 0, 0);\n    return ground;\n  };</code></pre>\n      </div>\n<p>最后,将所有的元素放置到空白 HTML 中的<code>canvas</code>中</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>/**\n   * 当请求数据时更新动画\n   */\n  _renderLine = scene => {\n    // 页面加载完毕调用动画\n    this._beginAnimation(scene, this.startData);\n    // 根据props中duration来决定数据请求的间隔时间\n    this.lineInterval = setInterval(() => {\n      // 更新数据源\n      this.startData = data;\n      this._beginAnimation(scene, this.startData);\n    }, this.props.duration);\n  };\n\n  /**\n   * 运行动画\n   */\n  _beginAnimation = scene => {\n    // 构建路线\n    const routes = lib.parabola(this.startData, 100);\n    const alpha = 0;\n    lib.updataLine(scene, this.startData, routes, alpha);\n  };\n\n  _onResize = engine => {\n    engine.resize();\n  };\n\n_onLoaded = canvas => {\n    this.engine = new BABYLON.Engine(canvas, true);\n    const createScene = () => {\n      const scene = new BABYLON.Scene(this.engine);\n      this._initCameras(scene, canvas);\n      this._initLights(scene);\n      this._initGround(scene);\n      this._renderLine(scene);\n      return scene;\n    };\n    const scene = createScene();\n    this._renderLoop(this.engine, scene);\n    window.addEventListener(\'resize\', () => {\n      this._onResize(this.engine);\n    });\n  };</code></pre>\n      </div>\n<p>打完, 收工</p>\n<h1>总结</h1>\n<p>3D 打击效果实现的要点主要就是怎么去算出这条打击轨迹.这就需要运用数学和物理上的相关知识了.</p>\n<p>从数学角度来看,打击轨迹就是一条抛物线.所以只需求出已知两点的抛物线就可以得到这条打击轨迹了.但单从数学的角度来做的话,实现起来太过于麻烦.但仔细观察就可以发现这条抛物线是对称的,并且有一半是在做平抛运动,所以只要通过物理上平抛运动的方程就可以解决问题.</p>\n<p>水平方向运动可以将其看成是沿<code>x轴</code>和<code>z轴</code>的水平匀速运动.最后通过水平方向运动得到的坐标带入平抛运动方程中,求出竖直方向的坐标,然后对称,就可以得到这条抛物线的所有坐标点了.</p>\n<p>线条运动说穿了就是点的移动,有了抛物线的坐标点,只需安装Babylon.js的规范实现点的移动就可以展示打击效果了</p>',fields:{slug:"/2018-03-16-yuan-chuang-ji-yu-babylonjs-shi-xian-3d-da-ji-xiao-guo/"},frontmatter:{title:"基于 Babylon.js 实现 3D 打击效果",date:"2018-03-16",catalog:"前端",author:"zhangsl2"}},allMarkdownRemark:{edges:[{node:{fields:{slug:"/2018-03-25-ru-he-xie-yi-ge-gao-bi-ge-readme/howToWrite/"},frontmatter:{title:""}}},{node:{fields:{slug:"/2018-10-07-dapp-dev-practice/"},frontmatter:{title:"区块链上编程：DApp 开发实践"}}},{node:{fields:{slug:"/2018-09-27-yi-chao-shi-yong-7-ge-you-xiu-de-ui-jiao-hu-dong-hua-ji-qiao/"},frontmatter:{title:"【译】超实用！7 个优秀的 UI 交互动画技巧"}}},{node:{fields:{slug:"/2018-09-25-guan-yu-http2-de-yan-jiu/"},frontmatter:{title:"关于 HTTP2 的研究"}}},{node:{fields:{slug:"/2018-09-25- heretic-judger-1/"},frontmatter:{title:"异端审判器！一个泛用型文本聚类模型的实现（1）"}}},{node:{fields:{slug:"/2018-09-25-wo-men-ying-gai-zuo-xie-li-suo-neng-ji-de-you-hua/"},frontmatter:{title:"我们应该做些力所能及的优化"}}},{node:{fields:{slug:"/2018-09-19-yi-yu-yong-hu-lian-xi-zai-wang-ye-she-ji-zhong-rong-ru-you-mo/"},frontmatter:{title:"【译】与用户联系：在网页设计中融入幽默"}}},{node:{fields:{slug:"/2018-09-19-yi-ru-he-she-ji-geng-hao-de-shu-ju-biao/"},frontmatter:{title:"【译】如何设计更好的数据表"}}},{node:{fields:{slug:"/2018-09-12-qian-duan-gong-cheng-hua-jiao-shou-jia/"},frontmatter:{title:"前端工程化：脚手架"}}},{node:{fields:{slug:"/2018-09-12-qian-tan-vue-zhong-computed-shi-xian-yuan-li/"},frontmatter:{title:"浅谈 Vue 中 computed 实现原理"}}},{node:{fields:{slug:"/2018-08-31-jian-shu-da-shu-ju-shi-shi-chu-li-kuang-jia/"},frontmatter:{title:"简述大数据实时处理框架"}}},{node:{fields:{slug:"/2018-08-22-shen-ru-promise/"},frontmatter:{title:"深入Promise"}}},{node:{fields:{slug:"/2018-08-13-tcp-lian-jie-ji-chang-jian-gong-ji-shou-fa-fen-xi/"},frontmatter:{title:"要点梳理：TCP连接及常见攻击手法分析"}}},{node:{fields:{slug:"/2018-08-13-ran-bing-luan-bf-ke-pu-bf-jie-shi-qi-de-js-shi-xian/"},frontmatter:{title:"然并卵：BF 科普 & BF 解释器的 JS 实现"}}},{node:{fields:{slug:"/2018-08-10-dapp-kai-fa-jian-jie/"},frontmatter:{title:"DApp 开发简介"}}},{node:{fields:{slug:"/2018-08-09-shi-lian-zhi-shi-performance/"},frontmatter:{title:"试炼之石-Performance"}}},{node:{fields:{slug:"/2018-08-09-prolog/"},frontmatter:{title:"那迷人的被遗忘的语言：Prolog"}}},{node:{fields:{slug:"/2018-08-08-qiao-qiao-xian-qi-webassembly-de-shen-mi-mian-sha/"},frontmatter:{title:"悄悄掀起 WebAssembly 的神秘面纱"}}},{node:{fields:{slug:"/2018-04-16-fan-yi-2018-nian-12-zhong-yi-dong-duan-yong-hu-ti-yan-she-ji-qu-shi/"},frontmatter:{title:"【翻译】2018 年 12 种移动端用户体验设计趋势"}}},{node:{fields:{slug:"/2018-04-08-fan-yi-mei-ge-uiux-she-ji-shi-du-xu-yao-zhi-dao-de-xin-li-xue-yuan-li/"},frontmatter:{title:"【翻译】每个 UI / UX 设计师都需要知道的心理学原理"}}},{node:{fields:{slug:"/2018-04-07-fan-yi-yan-fa-ren-yuan-de-sheng-chan-li-shi-fou-ke-yi-liang-hua/"},frontmatter:{title:"【翻译】研发人员的生产力是否可以量化"}}},{node:{fields:{slug:"/2018-04-01-fan-yi-jie-he-tu-xing-he-yu-yin-jie-mian-ti-gong-geng-hao-de-yong-hu-ti-yan/"},frontmatter:{title:"【翻译】结合图形和语音界面，提供更好的用户体验"}}},{node:{fields:{slug:"/2018-03-31-fan-yi-http1-dao-http2-de-yan-bian-ru-he-gai-bian-liao-web/"},frontmatter:{title:"【译】HTTP1 到 HTTP 2 的演变如何改变了 web"}}},{node:{fields:{slug:"/2018-03-28-shui-dong-liao-wo-de-dom/"},frontmatter:{title:"谁动了我的 DOM？！"}}},{node:{fields:{slug:"/2018-03-27-fan-yi-wei-kai-yuan-ruan-jian-she-ji/"},frontmatter:{title:"【翻译】为开源软件设计"}}},{node:{fields:{slug:"/2018-03-27-fan-yi-nodejstwofactor-shen-fen-ren-zheng/"},frontmatter:{title:"【译】node.js Two-Factor 身份认证"}}},{node:{fields:{slug:"/2018-03-25-react-server-side-render-with-hapi/"},frontmatter:{title:"服务端渲染和静态化"}}},{node:{fields:{slug:"/2018-03-25-ru-he-xie-yi-ge-gao-bi-ge-readme/"},frontmatter:{title:"如何写一个高逼格 README"}}},{node:{fields:{slug:"/2018-03-25-quan-zhan-gong-cheng-shi-zhi-lu-reactnative-zhi-sao-miao-er-wei-ma/"},frontmatter:{title:"全栈工程师之路-React Native之扫描二维码"}}},{node:{fields:{slug:"/2018-03-22-wu-xian-wang-luo-ling-lei-xiu-tan/"},frontmatter:{title:"无线网络另类嗅探"}}},{node:{fields:{slug:"/2018-03-19-fan-yi-shi-yong-de-ui-dong-hua-ji-qiao-gai-jin-ui-wei-jiao-hu-de-shi-yong-jian-yi/"},frontmatter:{title:"【翻译】实用的 UI 动画技巧——改进 UI 微交互的实用建议"}}},{node:{fields:{slug:"/2018-03-19-reactref-zhi-bei-jiao-cheng/"},frontmatter:{title:"React ref 指北教程"}}},{node:{fields:{slug:"/2018-03-18-fan-yi-how-to-prevent-your-node.js-process-from-crashing/"},frontmatter:{title:"【翻译】 如何使你的 Node 应用免于崩溃"}}},{node:{fields:{slug:"/2018-03-17-yi-zhong-qian-hou-duan-fen-li-de-kua-yu-kai-fa-fang-shi/"},frontmatter:{title:"一种方便的跨域开发解决方案"}}},{node:{fields:{slug:"/2018-03-16-yuan-chuang-ji-yu-babylonjs-shi-xian-3d-da-ji-xiao-guo/"},frontmatter:{title:"基于 Babylon.js 实现 3D 打击效果"}}},{node:{fields:{slug:"/2018-03-13-fan-yi-ru-he-chuang-jian-jiao-hu-you-hao-de-biao-dan/"},frontmatter:{title:"【译】如何创建交互友好的表单"}}},{node:{fields:{slug:"/2018-03-12-fan-yi-rang-wo-men-cong-ling-kai-shi-bian-bian-xie-yi-ge-web-fu-wu-qi/"},frontmatter:{title:"【译】让我们从零开始编写一个web服务器"}}},{node:{fields:{slug:"/2018-03-11-bikeshedding/"},frontmatter:{title:"由屎色自行车棚引发的思考"}}},{node:{fields:{slug:"/2018-03-11-xin-shou-shi-jiao-de-docker/"},frontmatter:{title:"新手视角的 Docker"}}},{node:{fields:{slug:"/2018-03-07-fan-yi-ji-yu-cypress-ce-shi-react-ying-yong/"},frontmatter:{title:"【译】基于 Cypress 测试 React 应用"}}},{node:{fields:{slug:"/2018-03-05-fan-yi-ru-he-zhao-dao-wan-mei-de-se-cai-da-pei-jie-shao-colorclaim/"},frontmatter:{title:"【译】如何找到完美的色彩搭配 - 介绍 ColorClaim"}}},{node:{fields:{slug:"/2018-03-05-ru-he-shi-yong-mac-po-jie-wifi/"},frontmatter:{title:"如何使用Mac破解Wifi"}}},{node:{fields:{slug:"/2018-03-05-yi-ge-chrome-kuo-zhan-jiu-zhe-yang-dan-sheng-liao/"},frontmatter:{title:"程序员偷懒指南——用chrome插件实现前端资讯推送"}}},{node:{fields:{slug:"/2018-03-01-wei-xian-de-targetblank-yu-opener/"},frontmatter:{title:'危险的 target="_blank" 与 “opener”'}}},{node:{fields:{slug:"/2018-02-28-activerecord-he-datamappers-mo-shi-jian-jie/"},frontmatter:{title:"Active Record 和 Data Mappers 模式简介"}}},{node:{fields:{slug:"/2018-02-26-bu-jin-jin-shi-piao-liang-tu-xiang-ru-he-qu-dong-yong-hu-ti-yan/"},frontmatter:{title:"【译】不仅仅是漂亮：图像如何驱动用户体验"}}},{node:{fields:{slug:"/2018-02-23-css3-clip-path-yong-fa-jie-shao/"},frontmatter:{title:"CSS3 clip-path 用法介绍"}}},{node:{fields:{slug:"/2018-02-23-du-shu-bi-ji-ke-shi-hua-shi-yi-zhong-yi-shu-bu-zhi-shi-mei-xin-xi-tu-biao-she-ji-yuan-li-yu-jing-dian-an-li-xu-zhang/"},frontmatter:{title:"读书笔记：可视化是一种艺术 -《不只是美：信息图表设计原理与经典案例》序章"}}},{node:{fields:{slug:"/2018-02-23-mei-ge-node-ying-yong-ke-neng-cun-zai-de-timing-attack-an-quan-lou-dong/"},frontmatter:{title:"每个 node 应用可能存在的 timing-attack 安全漏洞"}}},{node:{fields:{slug:"/2018-02-09-zan-lai-liao-liao-vuecompile/"},frontmatter:{title:"咱来聊聊 Vue - compile"}}},{node:{fields:{slug:"/2018-02-05-ji-yi-ci-jian-dan-de-csrf-gong-ji-shi-yan/"},frontmatter:{title:"记一次简单的 CSRF 攻击实验"}}},{node:{fields:{slug:"/2018-02-04-fan-yi-reactscope-jie-shao/"},frontmatter:{title:"【译】React Scope介绍"}}},{node:{fields:{slug:"/2018-02-03-fan-yi-liu-ge-xuan-ze-ui-yan-se-de-ji-qiao/"},frontmatter:{title:"【译】六个选择UI颜色的技巧"}}},{node:{fields:{slug:"/2018-02-03-huo-yong-git-apply-he-ru-patch-bu-ding/"},frontmatter:{title:"活用 git apply 合入 patch 补丁"}}},{node:{fields:{slug:"/2018-02-03-wo-de-di-yi-ge-node-ming-ling-hang-gong-ju/"},frontmatter:{title:"我的第一个 Node 命令行工具"}}},{node:{fields:{slug:"/2018-02-01-fan-yi-react-xin-de-contextapi/"},frontmatter:{title:"【译】React ⚛️  新的 Context API"}}},{node:{fields:{slug:"/2018-01-29-kuai-su-da-jian-ni-de-github-page-ge-ren-bo-ke-ji-yu-createreactapp-de-dan-ye-mian-ying-yong-shi-jian/"},frontmatter:{title:"快速搭建你的 github pages 个人博客 —— 基于 Create-React-App 的单页面应用实践"}}},{node:{fields:{slug:"/2018-01-28-redux-promise-middleware/"},frontmatter:{title:"一个插件让你在 Redux 中写 promise 事半功倍"}}},{node:{fields:{slug:"/2018-01-28-fan-yi-react-zu-jian-mo-shi/"},frontmatter:{title:"【译】React 组件设计模式基础"}}},{node:{fields:{slug:"/2018-01-28-fan-yi-bu-yao-rang-yong-hu-zai-chan-pin-ti-yan-shang-shou-dao-cuo-zhe/"},frontmatter:{title:"【译】不要让用户在产品体验上受到挫折"}}},{node:{fields:{slug:"/2018-01-27-javascript-mo-huan-dai-li/"},frontmatter:{title:"JavaScript 魔幻代理"}}},{node:{fields:{slug:"/2018-01-22-web-qian-duan-jian-dan-ding-yue-de-shi-xian/"},frontmatter:{title:"Web前端简单订阅的实现"}}},{node:{fields:{slug:"/2018-01-21-how-django-works/"},frontmatter:{title:"从请求到响应 django 都做了哪些处理"}}},{node:{fields:{slug:"/2018-01-21-electron-with-react/"},frontmatter:{title:"React+Electron搭建一个桌面应用"}}},{node:{fields:{slug:"/2018-01-20-fan-yi-ui-she-ji-zhong-de-ge-shi-ta-yuan-ze/"},frontmatter:{title:"【译】UI 设计中的格式塔原则"}}},{node:{fields:{slug:"/2018-01-19-xia-yi-dai-tong-xin-xie-yi-quic/"},frontmatter:{title:"下一代通信协议：QUIC"}}},{node:{fields:{slug:"/2018-01-19-fan-yi-shi-yong-css-zhui-zong-yong-hu/"},frontmatter:{title:"【译】使用 CSS 追踪用户"}}},{node:{fields:{slug:"/2018-01-14-antd-yuan-ma-jie-du-notification/"},frontmatter:{title:"antd 源码解读 notification"}}},{node:{fields:{slug:"/2018-01-14-ui-zhong-de-pai-ban-chu-xue-zhe-zhi-nan/"},frontmatter:{title:"【译】UI 中的排版：初学者指南"}}},{node:{fields:{slug:"/2018-01-14-learn-koa-intro/"},frontmatter:{title:"koa包教包会(一)——白话koa"}}},{node:{fields:{slug:"/2018-01-13-zi-ji-dong-shou-xie-yi-ge-simplevue/"},frontmatter:{title:"自己动手写一个 SimpleVue"}}},{node:{fields:{slug:"/2018-01-12-translation-React-Animations-in-Depth/"},frontmatter:{title:"【译】React Web 动画的 5 种创建方式，每一种都不简单"}}},{node:{fields:{slug:"/2018-01-10-ru-he-kuo-zhan-create-react-app-de-webpack-pei-zhi/"},frontmatter:{title:"如何扩展 Create React App 的 Webpack 配置"}}},{node:{fields:{slug:"/2018-01-08-mapbox-gl-js/"},frontmatter:{title:"3D GIS 应用开发 —— 基于 Mapbox GL 的实践总结"}}},{node:{fields:{slug:"/2018-01-07-the-importance-of-visual-appeal-in-web-design/"},frontmatter:{title:"【译】视觉吸引力在网页设计中的重要性"}}},{node:{fields:{slug:"/2018-01-06-react-higher-order-component/"},frontmatter:{title:"React 高阶组件介绍"}}},{node:{fields:{slug:"/2018-01-05-to-vim/"},frontmatter:{title:"如何让 vim 成为我们的神器"}}},{node:{fields:{slug:"/2018-01-05-d3-js-v3-data-driven-and-d3-force/"},frontmatter:{title:"D3.js 数据驱动 和 force 力学图讲解"}}},{node:{fields:{slug:"/2018-01-05-create-a-redux-middleware/"},frontmatter:{title:"如何编写一个 Redux 中间件"}}}]}},pathContext:{slug:"/2018-03-16-yuan-chuang-ji-yu-babylonjs-shi-xian-3d-da-ji-xiao-guo/"}}}});
//# sourceMappingURL=path---2018-03-16-yuan-chuang-ji-yu-babylonjs-shi-xian-3-d-da-ji-xiao-guo-fd857b368dc965e46999.js.map