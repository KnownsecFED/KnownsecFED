webpackJsonp([6018814991695],{662:function(n,a){n.exports={data:{site:{siteMetadata:{title:"创宇前端 - 最酷开发者的技术分享",author:"KnownsecFED",siteUrl:"https://knownsec-fed.com"}},markdownRemark:{id:"/tmp/app/src/pages/2018-10-05-ni-ting-shuo-guo-yuan-sheng-html-zu-jian-ma/index.md absPath of file >>> MarkdownRemark",html:'<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/header-359740780f601a98e72a48d83f3299e5-d6978.jpeg"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 1200px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAUBAgME/8QAFQEBAQAAAAAAAAAAAAAAAAAAAQD/2gAMAwEAAhADEAAAAW/KwkcSxH//xAAbEAABBAMAAAAAAAAAAAAAAAADAAECIgQQMv/aAAgBAQABBQKyx5kk42rofH//xAAXEQADAQAAAAAAAAAAAAAAAAAAAREh/9oACAEDAQE/AU8If//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/AWf/xAAZEAACAwEAAAAAAAAAAAAAAAAAARESIDL/2gAIAQEABj8CcOWOx1bH/8QAGhABAAMBAQEAAAAAAAAAAAAAAQARITFBUf/aAAgBAQABPyFCfGkB7J6uVCOuurK7A2ABQbP/2gAMAwEAAgADAAAAECv/AP/EABcRAQEBAQAAAAAAAAAAAAAAAAEAETH/2gAIAQMBAT8QxQnZA4X/xAAYEQEBAAMAAAAAAAAAAAAAAAABABEhMf/aAAgBAgEBPxAZRjm7/8QAHBABAAMBAAMBAAAAAAAAAAAAAQARITFRYZHR/9oACAEBAAE/EHVmEHA2x3xMZcaxrQo7+RCKr7b9HypS8HYBgI9i0tHW+z//2Q==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="你听说过原生 HTML 组件吗？"\n        title=""\n        src="/static/header-359740780f601a98e72a48d83f3299e5-d6978.jpeg"\n        srcset="/static/header-359740780f601a98e72a48d83f3299e5-527f0.jpeg 300w,\n/static/header-359740780f601a98e72a48d83f3299e5-9a7cd.jpeg 600w,\n/static/header-359740780f601a98e72a48d83f3299e5-d6978.jpeg 1200w"\n        sizes="(max-width: 1200px) 100vw, 1200px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<blockquote>\n<p>嘿！看看这几年啊，Web 前端的发展可是真快啊！</p>\n<p>想想几年前，HTML 是前端开发者的基本技能，通过各式各样的标签就可以搭建一个可用的网站，基本交互也不是问题。如果再来点 CSS，嗯，金黄酥脆，美味可口。这时候再撒上几把 JavaScript，简直让人欲罢不能。</p>\n<p>随着需求的增长，HTML 的结构越来越复杂，大量重复的代码使得页面改动起来异常困难，这也就孵化了一批批模版工具，将公共的部分抽取出来变为公共组件。再后来，随着 JavaScript 的性能提升，JavaScript 的地位越来越高，不再只是配菜了，前端渲染的出现降低了服务端解析模版的压力，服务端只要提供静态文件和 API 接口就行了嘛。再然后，前端渲染工具又被搬回了服务端，后端渲染出现了（黑人问号？？？）</p>\n<p>总之，组件化使得复杂的前端结构变得清晰，各个部分独立起来，高内聚低耦合，使得维护成本大大降低。</p>\n<p>那么，你有听说过原生 HTML 组件吗？</p>\n</blockquote>\n<h1>四大 Web 组件标准</h1>\n<p>在说原生 HTML 组件之前，要先简单介绍一下四大 Web 组件标准，四大 Web 组件标准分别为：HTML Template、Shadow DOM、Custom Elements 和 HTML Imports。实际上其中一个已经被废弃了，所以变成“三大”了。</p>\n<p>HTML Template 相信很多人都有所耳闻，简单的讲也就是 HTML5 中的 <code>&#x3C;template></code> 标签，正常情况下它无色无味，感知不到它的存在，甚至它下面的 img 都不会被下载，script 都不会被执行。<code>&#x3C;template></code> 就如它的名字一样，它只是一个模版，只有到你用到它时，它才会变得有意义。</p>\n<p>Shadow DOM 则是原生组件封装的基本工具，它可以实现组件与组件之间的独立性。</p>\n<p>Custom Elements 是用来包装原生组件的容器，通过它，你就只需要写一个标签，就能得到一个完整的组件。</p>\n<p>HTML Imports 则是 HTML 中类似于 ES6 Module 的一个东西，你可以直接 import 另一个 html 文件，然后使用其中的 DOM 节点。但是，由于 HTML Imports 和 ES6 Module 实在是太像了，并且除了 Chrome 以外没有浏览器愿意实现它，所以它已经被废弃并不推荐使用了。未来会使用 ES6 Module 来取代它，但是现在貌似还没有取代的方案，在新版的 Chrome 中这个功能已经被删除了，并且在使用的时候会在 Console 中给出警告。警告中说使用 ES Modules 来取代，但是我测试在 Chrome 71 中 ES Module 会强制检测文件的 MIME 类型必须为 JavaScript 类型，应该是暂时还没有实现支持。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/00-83259512f0eb8dc4bd12fa21741c71e7-27b4d.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 577px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 8.318890814558058%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsSAAALEgHS3X78AAAAjElEQVQI1x3N2wqCQABF0f7/c6IMI4i8UZozaFkkeUfHzAr6gd3k03rZnDMbKo9H6fJqA/rSmVS5zacXfMeYLrNQhUOXO7yV0I03OequSi3KdIeqfZq7w9AKZok0iY8Gp9Ak0t7OW8R+jjwskP6SKDC4yBX9fzSzKZI11XWjT1yeSh/WAtUI2jqk0/4AlbCMIRXBcxgAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="Deprecated HTML Imports"\n        title=""\n        src="/static/00-83259512f0eb8dc4bd12fa21741c71e7-27b4d.png"\n        srcset="/static/00-83259512f0eb8dc4bd12fa21741c71e7-e2e02.png 300w,\n/static/00-83259512f0eb8dc4bd12fa21741c71e7-27b4d.png 577w"\n        sizes="(max-width: 577px) 100vw, 577px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h1>Shadow DOM</h1>\n<p>要说原生 HTML 组件，就要先聊聊 Shadow DOM 到底是个什么东西。</p>\n<p>大家对 DOM 都很熟悉了，在 HTML 中作为一个最基础的骨架而存在，它是一个树结构，树上的每一个节点都是 HTML 中的一部分。DOM 作为一棵树，它拥有着上下级的层级关系，我们通常使用“父节点”、“子节点”、“兄弟节点”等来进行描述（当然有人觉得这些称谓强调性别，所以也创造了一些性别无关的称谓）。子节点在一定程度上会继承父节点的一些东西，也会因兄弟节点而产生一定的影响，比较明显的是在应用 CSS Style 的时候，子节点会从父节点那里继承一些样式。</p>\n<p>而 Shadow DOM，也是 DOM 的一种，所以它也是一颗树，只不过它是长在 DOM 树上的一棵特殊的紫薯🍠，啊不，子树。</p>\n<p>什么？DOM 本身不就是由一棵一棵的子树组成的吗？这个 Shadow DOM 有什么特别的吗？</p>\n<p>Shadow DOM 的特别之处就在于它致力于创建一个相对独立的一个空间，虽然也是长在 DOM 树上的，但是它的环境却是与外界隔离的，当然这个隔离是相对的，在这个隔离空间中，你可以选择性地从 DOM 树上的父节点继承一些属性，甚至是继承一棵 DOM 树进来。</p>\n<p>利用 Shadow DOM 的隔离性，我们就可以创造原生的 HTML 组件了。</p>\n<p>实际上，浏览器已经通过 Shadow DOM 实现了一些组件了，只是我们使用过却没有察觉而已，这也是 Shadow DOM 封装的组件的魅力所在：你只管写一个 HTML 标签，其他的交给我。（是不是有点像 React 的 JSX 啊？）</p>\n<p>我们来看一看浏览器利用 Shadow DOM 实现的一个示例吧，那就是 video 标签：</p>\n<div class="gatsby-highlight">\n      <pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>video</span> <span class="token attr-name">controls</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./video.mp4<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>400<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>300<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>video</span><span class="token punctuation">></span></span>\n</code></pre>\n      </div>\n<p>我们来看一下浏览器渲染的结果：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/01-dbe3d2fc211c09465557671c45fdcd2c-c9279.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 982px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 44.704684317718936%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAACOUlEQVQoz3WSzUtUURjG75/Rpk0tKoo2LVq4KQlq0RcmJJSoTdMIWka5scIwSe1jNHGhRLWIWkhUREZBWokRkhWEOWUQajDjzP2c+31nnLm/zlyTVr3w8LyHc87D8z68UnphPszoGVRVCzVdx3IcTMtmOafwO50lpxrImoGi5SOWI17D2tkIs4qGrBqhxGqFlCBwigRuAc/2CbwgurAdV4hpLMuK+KAiK/+giPNyNoeRN9E0PdQNA2lkZjRMvkzSNdoZjkwN0f94kO7b17k40MOFwV7m5n9gCSfprI7rFSiXVigJrKyscjHiUigqYmljy0723TzM8eR+2h+10tDXyJa6Hayv28S6oxt4NTmOsaSgpjPYeQNN94Q7F0u4MTQTS8RkaBamGN00TaSaW7XcvddBX7ye6Y9vmE19o7r5ALs791DTVcvE+3e4somqqQS+j+N4eCKOSu97vug9gkKRwl9Il+63cuNhGx1XjnH3wVm+pF4z8nSAO8+TdA+3MzY1juv4yHIOy7LQRZ6yLJPNZkWGCrrIMbAtCq6DKyBt3lVFTeNeDjVUUV27jXOXm+i8dp6600fYfnArEx/eitxC/MCPciuXy8JJIXJm2R7Z1BiL0/2Yc8PkM9+RWs60EYslqG9oJJ5IED8Vp+nkCWLxGPHmBF8/zYiHGRaWliKRilhFuFgs4optWEyNMvSih2eTvTi5WdbW5r+VFyNWBM18Htu2o+DFioi9FeMaNsbPJ/z6fJXFmR48ZZ4/7A9iUR+Kbl4AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="Video Tag"\n        title=""\n        src="/static/01-dbe3d2fc211c09465557671c45fdcd2c-c9279.png"\n        srcset="/static/01-dbe3d2fc211c09465557671c45fdcd2c-656e2.png 300w,\n/static/01-dbe3d2fc211c09465557671c45fdcd2c-e99e6.png 600w,\n/static/01-dbe3d2fc211c09465557671c45fdcd2c-c9279.png 982w"\n        sizes="(max-width: 982px) 100vw, 982px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>等一下！不是说 Shadow DOM 吗？这和普通 DOM 有啥区别？？？</p>\n<p>在 Chrome 中，Elements 默认是不显示内部实现的 Shadow DOM 节点的，需要在设置中启用：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/02-03da288f2fb093b2355ca9b2dce4cb0f-c9279.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 982px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 44.704684317718936%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAACSElEQVQoz3WS70tTYRTH988EEkRU9KaI3kUJhaFSSqE2t1VERVhBoIhRChVoGBGBP3pRIPQiSAhLhmllomZlklM3d+9+3R/b3b3b7u5+9elxIdSLDnw5h8PDc57zeb6u4OoykiKjajp6MolpZUibFlI0TiAoiawgR1XkmPon/yMFKa4hiXPhlQDrmxFcbEcZnFyRfM7BzuZxbKfazmSyaGJQXNFQdb06eFuakKJpmKaJsbCAHovhGv40xuDrfu4+72HU/5hHYw/pfXKPzgd36Rro42dgFTNpEEsY2PkClXKJcqlIuVwmb9tIkkQkGkOORMQ2CVw13gPU9TXg6TtJ94treG+3sbdxPzUNO9nRWMO7aT/JsIomEFhpg6SRQ9GzWIYhXmiwtr7BRjBENKEQlsXKTfdPMzLURa+vjfn59yx9W+Ko9wS1t47R3NXE1IdpMqop+Oo4+TzZnI0tcORFnctm2QytocYjFJMJtISMq2foKv2jHXR2tzDy7CZflid5+nKA4VcD3Bm8wZsZP1nBVFVVLMsiKXhu1aqSICQrTCxKfByfZWZmA/+KgWvX4YOcaq2l7swhjtTv4XpnO929HTRfrGff8d1MzU4Lbr9wnDylUolKpSJqh2LBISirTM4FeDsXZuKrzvhnCdely1dwu72cbWnF4/Ph8Xpoaz+H2+PGd+E83xcXSInf2wxLYlWbQqFQvbgolLFMbHVd4NAoWAqFlPSXbf4TaWEVI771IWlhoUzVIqlUCl30kymDTPSHYBzClJexNJnfOalgOVBxkxIAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="Turn on Shadow DOM 1"\n        title=""\n        src="/static/02-03da288f2fb093b2355ca9b2dce4cb0f-c9279.png"\n        srcset="/static/02-03da288f2fb093b2355ca9b2dce4cb0f-656e2.png 300w,\n/static/02-03da288f2fb093b2355ca9b2dce4cb0f-e99e6.png 600w,\n/static/02-03da288f2fb093b2355ca9b2dce4cb0f-c9279.png 982w"\n        sizes="(max-width: 982px) 100vw, 982px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    \n\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/03-776ac649b023f3e8a467a7fae60dc7bc-c9279.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 982px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 44.704684317718936%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAACEUlEQVQoz4WSy2sTURTG579w5UJc+KA7Fy660ULRRUWJQSpakpqkEVqtWDelErWCxGqsVZAg1oXoooi4ERTEilTamEJA1KldiJiSx0xmxmRmMnPndT/v3JBiceGBj3uGO/M73zlnhMrPdVrVqlAUlaqaBt000dIN1KQGypU6JEWDrPzunGqT5/WGtkXsjtZkFVJDowI6QeEDxHRB2g4swwaxCL+wiYNmS4dhtqE1m7yYZdtMBG3LZrJ43mrp1GRmhPzqAs29zuHaQobml+7jzos5XH84g6nZG5i6l8Xq5xLqkgTiEEiyjIaiwPM8EELg+z4opaFoWJw9U2Hn6H4cvn0Mp3MDuPR8DLFsHHsG92H7yV3YdmIH3iy9g+e4HKAyWOiCMIemYcBz3U57HR4vJETuRjH/eBLZ1BAKxUV8Eb+i7+wRHMz0I3I1ivfFj3BZ2x77yLAt6Azm8RkBQaggQDfCosLlJ2O49Wwck9OnMP/0AkriW+RfzuLRqxymH0xgsfiBOfERKGxJhRKqnwqorCyjymStf+fQrkMO3H2gF5H4IRyN9aIv2oOLV4aRuTmBwXPH0TOwF8ulFf6yr7ew8e0HlLU1kPIveBtlBGy2/7Q8en4ciUQaQ7E4Uuk0UiMpDCfPIDGSRJLloihutlQ1A9QUFTL7vQxCNmFbgPhPhJsMw3UcNNiW+cxCCDu7oL+BfwBCQmyEORKHOAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="Turn on Shadow DOM 2"\n        title=""\n        src="/static/03-776ac649b023f3e8a467a7fae60dc7bc-c9279.png"\n        srcset="/static/03-776ac649b023f3e8a467a7fae60dc7bc-656e2.png 300w,\n/static/03-776ac649b023f3e8a467a7fae60dc7bc-e99e6.png 600w,\n/static/03-776ac649b023f3e8a467a7fae60dc7bc-c9279.png 982w"\n        sizes="(max-width: 982px) 100vw, 982px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<blockquote>\n<p>注：浏览器默认隐藏自身的 Shadow DOM 实现，但如果是用户通过脚本创造的 Shadow DOM，是不会被隐藏的。</p>\n</blockquote>\n<p>然后，我们就可以看到 video 标签的真面目了：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/04-3b6aa74a06e060d023a702b79361ccbb-c9279.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 982px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 54.073319755600814%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAACrUlEQVQoz3WT22tTWRSHz18i+OTgiz744qBP4qOKLdpo1DIYVPBlZuyLoxYVL/XWOloRq7ZU7QyO4CjIqK3Seo2kRa2W0iZNmlvPdSfn5CRpzjmx/WYTmEEEF3ws1tqw9l78fltJTU+QMXJYlpAUKLlliUte1YknM2TnDHKq+T/f1jnVauRM3iCVmUPhv1gAPwio1TyqlXlq816jXalUsUQB3TAbl4pCEcMUmKbZyJqmN3qOU0IIgXIndp9rT7o592cHfXd6ud5/g64b3Ry/dJb2388wmZiiYBWZSWbRVZVsTic352CLIsIsUjAtOaiE5wdUqvMoP+z9kQ2nm/jp1Cb2n/+ZyKkDrGldy7Km5SzZuJTB6DBebYHJ8TipeJr4dJ6puE5yVpBJG0wnTJIpA0OTr7YclC0dW+m72U7nLxGuPh2m+3mcLQdbWN+2nubfmngz9qqxuhZPYKZmSCdU0jMaatYgLwfqOZOK7eCXbBZqLsqJW79ysb+Nw0dbuTTQzoN3j+j5u5Oe+52cv3aQ3qERYhoMvtd4Nppl6IPF4zGToU82g5LnkyVGpsqMTLu8jtsoK9etZceejYQi69iwbRVHTu7jdNchIm27WL15Bcdu/0NP1OdWVDAQsySCe6MWdyW3oyY3X2n0vbXoj7n0vZOitO6O0BIKs7m5mW07woR3hgmFQ7RIQttDvBh+JuUv4zkmQbmI5wpcS8XWs5SFKlcV8rwKdekKr4ziex5B4FOv1wl8H/8r6tJGpXIFW1Kt+QT1Lw1qns+8X6dkSyHGH5Id+wvx+R6l5MuvfPidqEqTG7OzzCVTmNI2mq5jGFJV6UlHfoj0i7P88aiDu4MXSLzvRVlcXOS7yIG+HKhNTKDn8xSLRVxZO45NVRo/cAuI2BU+jl5mNNpFbnyAfwHkpeuwwA6PewAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="True Face of Video Tag"\n        title=""\n        src="/static/04-3b6aa74a06e060d023a702b79361ccbb-c9279.png"\n        srcset="/static/04-3b6aa74a06e060d023a702b79361ccbb-656e2.png 300w,\n/static/04-3b6aa74a06e060d023a702b79361ccbb-e99e6.png 600w,\n/static/04-3b6aa74a06e060d023a702b79361ccbb-c9279.png 982w"\n        sizes="(max-width: 982px) 100vw, 982px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>在这里，你可完全像调试普通 DOM 一样随意调整 Shadow DOM 中的内容（反正和普通 DOM 一样，刷新一下就恢复了）。</p>\n<p>我们可以看到上面这些 shadow DOM 中的节点大多都有 <code>pseudo</code> 属性，根据这个属性，你就可以在外面编写 CSS 样式来控制对应的节点样式了。比如，将上面这个 <code>pseudo="-webkit-media-controls-overlay-play-button"</code> 的 input 按钮的背景色改为橙色：</p>\n<div class="gatsby-highlight">\n      <pre class="language-css"><code><span class="token selector">video::-webkit-media-controls-overlay-play-button</span> <span class="token punctuation">{</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> orange<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/05-29461ca5944efb316eac2a95780f11d1-c9279.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 982px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 71.38492871690428%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAADBElEQVQ4y4WT3YtUdRjH56/oqrvIm4i6iigQuoiwvYgyVq2bEErdWVejjGVjMzcFNUVoibKIoEi8EbwRW6KLXtBMbGpH186Ms3v27Hl/n3POzJx5O5+embYosHw4X57fc16+53n5PiVjTSnM0ML3gyIIQ9Iso5mkmI6LZto4foQXxHjhJoL437HADaLCdoORH5b40wr6kGc98laXdtohb+fjB2ma4Xg+puVgy08cwchb9ih2MCyLuJngB2ERN2NKH147V5y8dILD5+eLj74/w8nz73P44+PMnlpg9swx1nSNNG7iqjqxZWN7HpF8mCQJzWZzXFG/3y8GgwHdPC9KD0w9xrbT29l76hm+PvcClz/ZxcTuR7hvxxbuf+lBrv12g2Ezp+j1xhkPhjAc/l2XoJCrGIe9fo/S5OIkZz+b4+yeF+HXL2B1idm3n+LJ+WfZubCD6zcrxE6Esb6BJxmuaz62nRH5MZEXEboRUdii2x0QSj9Lc5+XOfHVARaO7uTql5OY373HhYtH+PTSB7yzeIBKfZkszrldUVhVVBqKTuOOg6r6aKpDreZiaA6hF+J6AaUtW5/guZefZtuux9m6/VHKc6/w5pH9PP/qBA9PPMSyUqXoFxhKHaO+ivK7S01xaTQ86nUXUw8lw4RMBhOGQvjGobeYKs/w2p697J+ZYXp6mn3lfUxNlzn4+kGq1SpxHHOrUuP2L7dYWW6gVOvcqWko42wFDRN1zRBynb9k85/W7rQJo0iy0Vi+cVPIVlhZqaFpJhu6M4amSW/XLYIgolRsTuluGBZDChlr3slxN2w0KdkxZSi6P/au6cnZwbV8IhF2KlL6X8KRufKiJRtjm5ZM18I0pDRNQ1dVbDk7tifi75CkOVGc3L3kfxJGsoZJqzXW2OjWSMCZiDltdUQ2Oql2nUT9ia7xM61AuzdhK01Ehw6xbEgc+tLTDr1uTtrukWkVqkuHuLh0lCs/zBOufnNvwlTWKxTCaJNwNPF2u0WrK701qtSuvsuFK4tc/vEYgfotfwA6bd8ZKJksNgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="Change Button Colour in Video Tag"\n        title=""\n        src="/static/05-29461ca5944efb316eac2a95780f11d1-c9279.png"\n        srcset="/static/05-29461ca5944efb316eac2a95780f11d1-656e2.png 300w,\n/static/05-29461ca5944efb316eac2a95780f11d1-e99e6.png 600w,\n/static/05-29461ca5944efb316eac2a95780f11d1-c9279.png 982w"\n        sizes="(max-width: 982px) 100vw, 982px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>由于 Shadow DOM 实际上也是 DOM 的一种，所以在 Shadow DOM 中还可以继续嵌套 Shadow DOM，就像上面那样。</p>\n<p>浏览器中还有很多 Element 都使用了 Shadow DOM 的形式进行封装，比如 <code>&#x3C;input></code>、<code>&#x3C;select></code>、<code>&#x3C;audio></code> 等，这里就不一一展示了。</p>\n<p>由于 Shadow DOM 的隔离性，所以即便是你在外面写了个样式：<code>div { background-color: red !important; }</code>，Shadow DOM 内部的 div 也不会受到任何影响。</p>\n<p>也就是说，写样式的时候，该用 id 的时候就用 id，该用 class 的时候就用 class，一个按钮的 class 应该写成 <code>.button</code> 就写成 <code>.button</code>。完全不用考虑当前组件中的 id、class 可能会与其他组件冲突，你只要确保一个组件内部不冲突就好——这很容易做到。</p>\n<p>这解决了现在绝大多数的组件化框架都面临的问题：Element 的 class(className) 到底怎么写？用前缀命名空间的形式会导致 class 名太长，像这样：<code>.header-nav-list-sublist-button-icon</code>；而使用一些 CSS-in-JS 工具，可以创造一些唯一的 class 名称，像这样：<code>.Nav__welcomeWrapper___lKXTg</code>，这样的名称仍旧有点长，还带了冗余信息。</p>\n<h2>ShadowRoot</h2>\n<p>ShadowRoot 是 Shadow DOM 下面的根，你可以把它当做 DOM 中的 <code>&#x3C;body></code> 一样看待，但是它不是 <code>&#x3C;body></code>，所以你不能使用 <code>&#x3C;body></code> 上的一些属性，甚至它不是一个节点。</p>\n<p>你可以通过 ShadowRoot 下面的 <code>appendChild</code>、<code>querySelectorAll</code> 之类的属性或方法去操作整个 Shadow DOM 树。</p>\n<p>对于一个普通的 Element，比如 <code>&#x3C;div></code>，你可以通过调用它上面的 <code>attachShadow</code> 方法来创建一个 ShadowRoot（还有一个 <code>createShadowRoot</code> 方法，已经过时不推荐使用），<code>attachShadow</code> 接受一个对象进行初始化：<code>{ mode: \'open\' }</code>，这个对象有一个 <code>mode</code> 属性，它有两个取值：<code>\'open\'</code> 和 <code>\'closed\'</code>，这个属性是在创造 ShadowRoot 的时候需要初始化提供的，并在创建 ShadowRoot 之后成为一个只读属性。</p>\n<p><code>mode: \'open\'</code> 和 <code>mode: \'closed\'</code> 有什么区别呢？在调用 <code>attachShadow</code> 创建 ShadowRoot 之后，<code>attachShdow</code> 方法会返回 ShadowRoot 对象实例，你可以通过这个返回值去构造整个 Shadow DOM。当 mode 为 <code>\'open\'</code> 时，在用于创建 ShadowRoot 的外部普通节点（比如 <code>&#x3C;div></code>）上，会有一个 <code>shadowRoot</code> 属性，这个属性也就是创造出来的那个 ShadowRoot，也就是说，在创建 ShadowRoot 之后，还是可以在任何地方通过这个属性再得到 ShadowRoot，继续对其进行改造；而当 mode 为 <code>\'closed\'</code> 时，你将不能再得到这个属性，这个属性会被设置为 <code>null</code>，也就是说，你只能在 <code>attachShadow</code> 之后得到 ShadowRoot 对象，用于构造整个 Shadow DOM，一旦你失去对这个对象的引用，你就无法再对 Shadow DOM 进行改造了。</p>\n<p>可以从上面 Shadow DOM 的截图中看到 <code>#shadow-root (user-agent)</code> 的字样，这就是 ShadowRoot 对象了，而括号中的 <code>user-agent</code> 表示这是浏览器内部实现的 Shadow DOM，如果使用通过脚本自己创建的 ShadowRoot，括号中会显示为 <code>open</code> 或 <code>closed</code> 表示 Shadow DOM 的 mode。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/06-ac0c4bca4e226b08db4c513feb202537-771b0.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 244px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 66.39344262295081%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAACF0lEQVQ4y52SyW7UQBCG560Q8ARISEhw5gHgLXgMlhtiuYCUQwJCERLcECSzZZkZO7NkHNuzeJnYHq/tj26bRBkRDqGkT1V2df2urnLj3uuQu68CHrwNebqd8OxbypOdlPtv1jx8F/LofcjjDxG3ngfcfnENLwPuXKHxRc/YGWRs9zO22g7bTYeP3y229n2+jgqJYHdY8Ekr+CzZGeR1rCtE9axqL2hwaSWIlLWzYNY7YWWZlFlEmYYyldSIWJ7Laq/IZI6Cq9YoRIkoS6JEIOSLpePQP9HY73bZazbZ63QxTIuBpnPYH+D6K3qDAT9lrnN4TLSOZT3kRUkug0YpxZQlmaiEi6KgKAtmUxv9l4Y5MlhYc7QffSYHQzzHI01TkiSpfBzHG2wIKovOA4z+FHto4js+aSKLY1kcp5KELMvqj/6DK4Jl1b6/cDF7BvOxTSqLb2p/BMtK0F+tcOT1pgdjlvaSQsgxiLpzUQjZgZCzKmRcd6NqVV7F1VrL8u8ru67D0fER+502rW6LvVYb07IYTUb0dA3X8zBNA03XaXU6dLpt7Nn8ekG1rWrgWcLMsBl1h5iTMxb2nJOmhqGd4ns+cRKzXq+JoqhCLUMtSbEpKBVjedAxl9hjC2toEXjnhKsA13TwbFfmY/I8J5fzrbxELeqCDUH1T/ozB+PwlPnIrrr9z6XUgv7SY9Iec9abEgbR5Vxuwm8GYNEBOnAyngAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="Open 的 ShadowRoot 与 不Open 的 ShadowRoot"\n        title=""\n        src="/static/06-ac0c4bca4e226b08db4c513feb202537-771b0.png"\n        srcset="/static/06-ac0c4bca4e226b08db4c513feb202537-771b0.png 244w"\n        sizes="(max-width: 244px) 100vw, 244px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<blockquote>\n<p>浏览器内部实现的 <code>user-agent</code> 的 mode 为 <code>closed</code>，所以你不能通过节点的 ShadowRoot 属性去获得其 ShadowRoot 对象，也就意味着你不能通过脚本对这些浏览器内部实现的 Shadow DOM 进行改造。</p>\n</blockquote>\n<h1>HTML Template</h1>\n<p>有了 ShadowRoot 对象，我们可以通过代码来创建内部结构了，对于简单的结构，也许我们可以直接通过 <code>document.createElement</code> 来创建，但是稍微复杂一些的结构，如果全部都这样来创建不仅麻烦，而且代码可读性也很差。当然也可以通过 ES6 提供的反引号字符串（<code>const template = `......`;</code>）配合 innerHTML 来构造结构，利用反引号字符串中可以任意换行，并且 HTML 对缩进并不敏感的特性来实现模版，但是这样也是不够优雅，毕竟代码里大段大段的 HTML 字符串并不美观，即便是单独抽出一个常量文件也是一样。</p>\n<p>这个时候就可以请 HTML Template 出场了。我们可以在 html 文档中编写 DOM 结构，然后在 ShadowRoot 中加载过来即可。</p>\n<p>HTML Template 实际上就是在 html 中的一个 <code>&#x3C;template></code> 标签，正常情况下，这个标签下的内容是不会被渲染的，包括标签下的 img、style、script 等都是不会被加载或执行的。你可以在脚本中使用 <code>getElementById</code> 之类的方法得到 <code>&#x3C;template></code> 标签对应的节点，但是却无法直接访问到其内部的节点，因为默认他们只是模版，在浏览器中表现为 <code>#document-fragment</code>，字面意思就是“文档片段”，可以通过节点对象的 <code>content</code> 属性来访问到这个 document-fragment 对象。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/07-2db037ad33745a668d25b8de5cb21ef8-1ddb6.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 257px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 26.848249027237355%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsSAAALEgHS3X78AAAA4ElEQVQY042PyW6DQBBE+f8/i3IIdiLFLMNAMGYgMhiGfXsZbEXKKUlLXepDq16VtawLjda4bycOTzahF+Ic34lkTBIFpEmMJ2J8Ick+c3TT8ttYu0zTRJqnBFIQCGPoushAkKmU+KwQwsO2X/A9h+J6ZRpnurZnnmeGdqDXHbPx2LYNa5fvGc1T6iT0VU99iakyRRRXjP3EWJeo05HiHFEW2sBuNHWNkoqP15AyL1nX9ZGwqcyDvBAeBP6zRx4qc0v0Td9BO/QH9+/Ki4m+Rx66waQcmE2lqR/vxIfZ//cLh2R/H8aWg7sAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="template document-fragment"\n        title=""\n        src="/static/07-2db037ad33745a668d25b8de5cb21ef8-1ddb6.png"\n        srcset="/static/07-2db037ad33745a668d25b8de5cb21ef8-1ddb6.png 257w"\n        sizes="(max-width: 257px) 100vw, 257px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>通过 document-fragment 对象，就可以访问到 template 内部的节点了，通过 <code>document.importNode</code> 方法，可以将 document-fragment 对象创建一份副本，然后可以使用一切 DOM 属性方法替换副本中的模版内容，最终将其插入到 DOM 或是 Shadow DOM 中。</p>\n<div class="gatsby-highlight">\n      <pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>div<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>temp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">const</span> template <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'temp\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> copy <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">importNode</span><span class="token punctuation">(</span>template<span class="token punctuation">.</span>content<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\ncopy<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'title\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">\'Hello World!\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'div\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> shadowRoot <span class="token operator">=</span> div<span class="token punctuation">.</span><span class="token function">attachShadow</span><span class="token punctuation">(</span><span class="token punctuation">{</span> mode<span class="token punctuation">:</span> <span class="token string">\'closed\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nshadowRoot<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<h1>HTML Imports</h1>\n<p>有了 HTML Template，我们已经可以方便地创造封闭的 Web 组件了，但是目前还有一些不完美的地方：我们必须要在 html 中定义一大批的 <code>&#x3C;template></code>，每个组件都要定义一个 <code>&#x3C;template></code>。</p>\n<p>此时，我们就可以用到已经被废弃的 HTML Imports 了。虽然它已经被废弃了，但是未来会通过 ES6 Modules 的形式再进行支持，所以理论上也只是换个加载形式而已。</p>\n<p>通过 HTML Imports，我们可以将 <code>&#x3C;template></code> 定义在其他的 html 文档中，然后再在需要的 html 文档中进行导入（当然也可以通过脚本按需导入），导入后，我们就可以直接使用其中定义的模版节点了。</p>\n<p>已经废弃的 HTML Imports 通过 <code>&#x3C;link></code> 标签实现，只要指定 <code>rel="import"</code> 就可以了，就像这样：<code>&#x3C;link rel="import" href="./templates.html"></code>，它可以接受 <code>onload</code> 和 <code>onerror</code> 事件以指示它已经加载完成。当然也可以通过脚本来创建 link 节点，然后指定 rel 和 href 来按需加载。Import 成功后，在 link 节点上有一个 <code>import</code> 属性，这个属性中存储的就是 import 进来的 DOM 树啦，可以 <code>querySelector</code> 之类的，并通过 <code>cloneNode</code> 或 <code>document.importNode</code> 方法创建副本后使用。</p>\n<p>未来新的 HTML Imports 将会以 ES6 Module 的形式提供，可以在 JavaScript 中直接 <code>import * as template from \'./template.html\';</code>，也可以按需 import，像这样：<code>const template = await import(\'./template.html\');</code>。不过目前虽然浏览器都已经支持 ES6 Modules，但是在 import 其他模块时会检查服务端返回文件的 MIME 类型必须为 JavaScript 的 MIME 类型，否则不允许加载。</p>\n<h1>Custom Elements</h1>\n<p>有了上面的三个组件标准，我们实际上只是对 HTML 进行拆分而已，将一个大的 DOM 树拆成一个个相互隔离的小 DOM 树，这还不是真正的组件。</p>\n<p>要实现一个真正的组件，我们就需要用到 Custom Elements 了，就如它的名字一样，它是用来定义原生组件的。</p>\n<p>Custom Elements 的核心，实际上就是利用 JavaScript 中的对象继承，去继承 HTML 原生的 <code>HTMLElement</code> 类（或是具体的某个原生 Element 类，比如 <code>HTMLButtonElement</code>），然后自己编写相关的生命周期函数，处理成员属性以及用户交互的事件。</p>\n<p>看起来这和现在的 React 很像，在 React 中，你可以这样创造一个组件：<code>class MyElement extends React.Component { ... }</code>，而使用原生 Custom Elements，你需要这样写：<code>class MyElement extends HTMLElement { ... }</code>。</p>\n<p>Custom Elements 的生命周期函数并不多，但是足够使用。这里我将 Custom Elements 的生命周期函数与 React 进行一个简单的对比:</p>\n<ul>\n<li>\n<p><code>constructor()</code>: 构造函数，用于初始化 state、创建 Shadow DOM、监听事件之类。</p>\n<p>对应 React 中 Mounting 阶段的大半部分，包括：<code>constructor(props)</code>、<code>static getDerivedStateFromProps(props, state)</code> 和 <code>render()</code>。</p>\n<p>在 Custom Elements 中，<code>constructor()</code> 构造函数就是其原本的含义：初始化，和 React 的初始化类似，但它没有像 React 中那样将其拆分为多个部分。在这个阶段，组件仅仅是被创建出来（比如通过 <code>document.createElement()</code>），但是还没有插入到 DOM 树中。</p>\n</li>\n<li>\n<p><code>connectedCallback()</code>: 组件实例已被插入到 DOM 树中，用于进行一些展示相关的初始化操作。</p>\n<p>对应 React 中 Mounting 阶段的最后一个生命周期：<code>componentDidMount()</code>。</p>\n<p>在这个阶段，组件已经被插入到 DOM 树中了，或是其本身就在 html 文件中写好在 DOM 树上了，这个阶段一般是进行一些展示相关的初始化，比如加载数据、图片、音频或视频之类并进行展示。</p>\n</li>\n<li>\n<p><code>attributeChangedCallback(attrName, oldVal, newVal)</code>: 组件属性发生变化，用于更新组件的状态。</p>\n<p>对应 React 中的 Updating 阶段：<code>static getDerivedStateFromProps(props, state)</code>、<code>shouldComponentUpdate(nextProps, nextState)</code>、<code>render()</code>、<code>getSnapshotBeforeUpdate(prevProps, prevState)</code> 和 <code>componentDidUpdate(prevProps, prevState, snapshot)</code>。</p>\n<p>当组件的属性（React 中的 props）发生变化时触发这个生命周期，但是并不是所有属性变化都会触发，比如组件的 <code>class</code>、<code>style</code> 之类的属性发生变化一般是不会产生特殊交互的，如果所有属性发生变化都触发这个生命周期的话，会使得性能造成较大的影响。所以 Custom Elements 要求开发者提供一个属性列表，只有当属性列表中的属性发生变化时才会触发这个生命周期函数。</p>\n<p>这个属性列表通过组件类上的一个<strong>静态只读</strong>属性来声明，在 ES6 Class 中使用一个 getter 函数来实现，只实现 getter 而不实现 setter，getter 返回一个常量，这样就是只读的了。像这样：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">AwesomeElement</span> <span class="token keyword">extends</span> <span class="token class-name">HTMLElement</span> <span class="token punctuation">{</span>\n  <span class="token keyword">static</span> <span class="token keyword">get</span> <span class="token function">observedAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">\'awesome\'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n</li>\n<li>\n<p><code>disconnectedCallback()</code>: 组件被从 DOM 树中移除，用于进行一些清理操作。</p>\n<p>对应 React 中的 Unmounting 阶段：<code>componentWillUnmount()</code>。</p>\n</li>\n<li>\n<p><code>adoptedCallback()</code>: 组件实例从一个文档被移动到另一个文档。</p>\n<p>这个生命周期是原生组件独有的，React 中没有类似的生命周期。这个生命周期函数也并不常用到，一般在操作多个 document 的时候会遇到，调用 <code>document.adoptNode()</code> 函数转移节点所属 document 时会触发这个生命周期。</p>\n</li>\n</ul>\n<p>在定义了自定义组件后，我们需要将它注册到 HTML 标签列表中，通过 <code>window.customElements.define()</code> 函数即可实现，这个函数接受两个必须参数和一个可选参数。第一个参数是注册的标签名，为了避免和 HTML 自身的标签冲突，Custom Elements 要求用户自定义的组件名必须至少包含一个短杠 <code>-</code>，并且不能以短杠开头，比如 <code>my-element</code>、<code>awesome-button</code> 之类都是可以的。第二个参数是注册的组件的 class，直接将继承的子类类名传入即可，当然也可以直接写一个匿名类：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code>window<span class="token punctuation">.</span>customElements<span class="token punctuation">.</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">\'my-element\'</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> HTMLElement <span class="token punctuation">{</span>\n  <span class="token operator">...</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>注册之后，我们就可以使用了，可以直接在 html 文档中写对应的标签，比如：<code>&#x3C;my-element>&#x3C;/my-element></code>，也可以通过 <code>document.createElement(\'my-element\')</code> 来创建，用法与普通标签几乎完全一样。但要注意的是，虽然 html 标准中说部分标签可以不关闭或是自关闭(<code>&#x3C;br></code> 或是 <code>&#x3C;br /></code>)，但是只有<a href="https://html.spec.whatwg.org/multipage/syntax.html#void-elements">规定的少数几个标签</a>允许自关闭，所以，在 html 中写 Custom Elements 的节点时必须带上关闭标签。</p>\n<p>由于 Custom Elements 是通过 JavaScript 来定义的，而一般 js 文件都是通过 <code>&#x3C;script></code> 标签外联的，所以 html 文档中的 Custom Elements 在 JavaScript 未执行时是处于一个默认的状态，浏览器默认会将其内容直接显示出来。为了避免这样的情况发生，Custom Elements 在被注册后都会有一个 <code>:defined</code> CSS 伪类而在注册前没有，所以我们可以通过 CSS 选择器在 Custom Elements 注册前将其隐藏起来，比如：</p>\n<div class="gatsby-highlight">\n      <pre class="language-css"><code><span class="token selector">my-element:not(:defined)</span> <span class="token punctuation">{</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>或者 Custom Elements 也提供了一个函数来检测指定的组件是否已经被注册：<code>customElements.whenDefined()</code>，这个函数接受一个组件名参数，并返回一个 Promise，当 Promise 被 resolve 时，就表示组件被注册了。</p>\n<p>这样，我们就可以放心的在加载 Custom Elements 的 JavaScript 的 <code>&#x3C;script></code> 标签上使用 <code>async</code> 属性来延迟加载了（当然，如果是使用 ES6 Modules 形式的话默认的加载行为就会和 <code>defer</code> 类似）。</p>\n<p><img src="/08-c9cc87051884db233601687712b81647.svg" alt="script async defer"></p>\n<h2>Custom Elements + Shadow DOM</h2>\n<p>使用 Custom Elements 来创建组件时，通常会与 Shadow DOM 进行结合，利用 Shadow DOM 的隔离性，就可以创造独立的组件。</p>\n<p>通常在 Custom Elements 的 <code>constructor()</code> 构造函数中去创建 Shadow DOM，并对 Shadow DOM 中的节点添加事件监听、对特定事件触发原生 Events 对象。</p>\n<p>正常编写 html 文档时，我们可能会给 Custom Elements 添加一些子节点，像这样：<code>&#x3C;my-element>&#x3C;h1>Title&#x3C;/h1>&#x3C;p>Content&#x3C;/p>&#x3C;/my-element></code>，而我们创建的 Shadow DOM 又拥有其自己的结构，怎样将这些子节点放置到 Shadow DOM 中正确的位置上呢？</p>\n<p>在 React 中，这些子节点被放置在 <code>props</code> 的 <code>children</code> 中，我们可以在 <code>render()</code> 时选择将它放在哪里。而在 Shadow DOM 中有一个特殊的标签：<code>&#x3C;slot></code>，这个标签的用处就如同其字面意思，在 Shadow DOM 上放置一个“插槽”，然后 Custom Elements 的子节点就会自动放置到这个“插槽”中了。</p>\n<p>有时我们需要更加精确地控制子节点在 Shadow DOM 中的位置，而默认情况下，所有子节点都会被放置在同一个 <code>&#x3C;slot></code> 标签下，即便是你写了多个 <code>&#x3C;slot></code>。那怎样更精确地对子节点进行控制呢？</p>\n<p>默认情况下，<code>&#x3C;slot>Fallback&#x3C;/slot></code> 这样的是默认的 <code>&#x3C;slot></code>，只有第一个默认的 <code>&#x3C;slot></code> 会有效，将所有子节点全部放进去，如果没有可用的子节点，将会显示默认的 Fallback 内容（Fallback 可以是一棵子 DOM 树）。</p>\n<p><code>&#x3C;slot></code> 标签有一个 <code>name</code> 属性，当你提供 <code>name</code> 后，它将变为一个“有名字的 <code>&#x3C;slot></code>”，这样的 <code>&#x3C;slot></code> 可以存在多个，只要名字各不相同。此时他们会自动匹配 Custom Elements 下带 <code>slot</code> 属性并且 <code>slot</code> 属性与自身 <code>name</code> 相同的子节点，像这样：</p>\n<div class="gatsby-highlight">\n      <pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Others<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Animals<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>animal<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Fruits<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fruit<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-list</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>animal<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Cat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fruit<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Apple<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fruit<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Banana<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>other<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>flower<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>pencil<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>animal<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Dog<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fruit<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>peach<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>red<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-list</span><span class="token punctuation">></span></span>\n</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">MyList</span> <span class="token keyword">extends</span> <span class="token class-name">HTMLElement</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">attachShadow</span><span class="token punctuation">(</span><span class="token punctuation">{</span> mode<span class="token punctuation">:</span> <span class="token string">\'open\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> template <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'list\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    root<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">importNode</span><span class="token punctuation">(</span>template<span class="token punctuation">.</span>content<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\ncustomElements<span class="token punctuation">.</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">\'my-list\'</span><span class="token punctuation">,</span> MyList<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>这样就可以得到如图所示的结构，<code>#shadow-root (open)</code> 表示这是一个开放的 Shadow DOM，下面的节点是直接从 template 中 clone 过来的，浏览器自动在三个 <code>&#x3C;slot></code> 标签下放置了几个灰色的 <code>&#x3C;div></code> 节点，实际上这些灰色的 <code>&#x3C;div></code> 节点表示的是到其真实节点的“引用”，鼠标移动到他们上会显示一个 <code>reveal</code> 链接，点击这个链接即可跳转至其真实节点。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/09-d99af21fbc36d96d55ec8aabe40c1893-df86d.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 478px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 133.68200836820083%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAAAsSAAALEgHS3X78AAAE1UlEQVRIx41VW2wUZRjddx98kIsQKO3sdnfnPrszu7Ozs7uz15ll2yWlkhBAEi8xvIhEa9CWKvhgYl+IwIMkxmuiT5JgiMZoqlIwvKBtaLDh0oaKAYlBorJtufX4zV/YUC7STU7mfv7zfec7/wZwz+/WrVvsODAwAEPXUSqV0NLSglg8jkg0Cj7Ko16vw3NdZDIZ2LYNy7LYueM4CIxPnMXgD9/jl5+PY3hkBOcmJxlhf38/1LiBSsVFykrDyeVgGxraw2GIkgRBEBCJRJoI031ZlhH4YP+H6PLWYcOGjah1rsWePfsY4eu9veBiaSTKddhuF6xSDZVsGpqmoTUYAkcIhtoJc0f/mhdEBL7+9hj6dr2H/Z8dwr6PDuCLb46iQYTbe7ZhFReERmRRWrmdFLXTB6GVSxFuXY7QqmW3Qecty8CtWAwhzCFw7NQlHDh+AYfPTmFoYgbfjf2Do+MNvDbwPkLOBjjP9MPa3Aej+0WY615B6aktMOtbIHa9DHXjmwxydw/CpWch5boQ+PPSH2j8+/dtS2ZvA9i593OsLG6B+/xb6Ny6G+UX3ob19BtIbexH5rl3IK99FeHaVkQ7thFeQqTeA7m8CQHf1es3bmBmZgY36Dg9PcMIe7f34InHH4Mm8Ujmy0g5eWSTGoyYjEQyATHcCj64EnyohSHKrYAshBH46cgRfPzJpzh46Ct8efAgdr+7F7+dP4+dO3dh0dLlkCUZStKG2bEe+bIHI2VDStgQFY3cVpoQCKoaQ8BXNTU1hanpaTSuXsXly38xhTt29GHx0mVsFCT6OGkX4BQ9mOkcvGoH4gkLvBQnYp1BkHUomo7AlStX0GhM3Tvf6OvrxRIiFEUREq2cLHjIFCvQacDTNMyqorBZ9J/78M8Vuhc4c/oMxscnGMnNmzcZ5ghJ4ZInoWoxGJU1iBVqbKjD7SGGKKVGFIUmaZNwdna2Gbe7o8cISaH/UixbgUmDXcwXkCPomQK0uN5UN4/w9KlTOHnyJMbGxjA6Oopr1643S2Y9pJhp1C8/MV5HN4q1blScLOq5FJEa9yv8lciGDv+Iw0NDGBwcxFUyho1N71wPJXJZ4KNImSY8r0oLiIhSdn2CO5hH+LDd5k7JEilUaWwMUhi3MqxvoijNK3Ue4eS5SZw4MUrKGvD7+VBTcmWmjI9GEOV58IQHujxBDg8Pj9Aw/950ep4pNIexTBGm1wXX9ZD36rAKLhI6zSA9u0/hxQsXcfrMWYrc9AMJWVJiOhJOGUW3E2a2jLSuUgx1lpb/7eG9JTNTmAoeZsJA1a1AIVMiUb9k4cEl+yR34z5ClhSKnlNBtuRCoOs5Mn4O1Ms7hOqjFPqmyBS7eL5KLq+BTKUbioi4Sm2gRWSCqM6V7Zv0yJIXLVrMdhYl5yGRdal/Bay1VJTtFMrVGkzqq5SrIkwt4Lg2RvxowmSWCF0YGR9FdCd5OPQPt37TZnSu6YJa6YZI73CtrQsjFEmhRhuDU1oN2ymiTLGLJVK0yZowzRSicYISA9e2QIViMgMtX0O2SIS5Amo5C3navuxcHnraAU/q/F2I47iFK1SJ0C5UaU9cDc/SkdJjqHirYdECQrqIiCAvTKHvskJbl+KQyxQ9XjPA8RLaSE0r9ayNEGwjBIOkMMgI/wOoSdFolyZ2+AAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="My List"\n        title=""\n        src="/static/09-d99af21fbc36d96d55ec8aabe40c1893-df86d.png"\n        srcset="/static/09-d99af21fbc36d96d55ec8aabe40c1893-fc2e9.png 300w,\n/static/09-d99af21fbc36d96d55ec8aabe40c1893-df86d.png 478w"\n        sizes="(max-width: 478px) 100vw, 478px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>这里我们可以看到，虽然 <code>&#x3C;my-list></code> 下的子节点是乱序放置的，但是只要是给定了 <code>slot</code> 属性，就会被放置到正确的 <code>&#x3C;slot></code> 标签下。注意观察其中有一个 <code>&#x3C;div slot="other">flower&#x3C;/div></code>，这个节点由于指定了 <code>slot="other"</code>，但是却找不到匹配的 <code>&#x3C;slot></code> 标签，所以它不会被显示在结果中。</p>\n<p>在为 Custom Elements 下的 Shadow DOM 设置样式的时候，我们可以直接在 Shadow DOM 下放置 <code>&#x3C;style></code> 标签，也可以放置 <code>&#x3C;link rel="stylesheet"></code>，Shadow DOM 下的样式都是局部的，所以不用担心会影响到 Shadow DOM 的外部。并且由于这些样式仅影响局部🌻，所以对性能也有很大的提升。</p>\n<p>在 Shadow DOM 内部的样式中，也有一些特定的选择器，比如 <code>:host</code> 选择器，代表着 ShadowRoot，这类似于普通 DOM 中的 <code>:root</code>，并且它可以与其他伪类组合使用，比如当鼠标在组件上时：<code>:host(:hover)</code>，当组件拥有某个 class 时：<code>:host(.awesome)</code>，当组件拥有 <code>disabled</code> 属性时：<code>:host([disabled])</code>……但是 <code>:host</code> 是拥有继承属性的，所以如果在 Custom Elements 外部定义了某些样式，将会覆盖 <code>:host</code> 中的样式，这样就可以轻松地实现各式各样的“主题风格”了。</p>\n<p>为了实现自定义主题，我们还可以使用 Shadow DOM 提供的 <code>:host-context()</code> 选择器，这个选择器允许检查 Shadow DOM 的任何祖先节点是否包含指定选择器。比如如果在最外层 DOM 的 <code>&#x3C;html></code> 或 <code>&#x3C;body></code> 上有一个 class：<code>.night</code>，则 Shadow DOM 内就可以使用 <code>:host-context(.night)</code> 来指定一个夜晚的主题。这样可以实现主题样式的继承。</p>\n<p>还有一种样式的定义方式是利用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables">CSS 变量</a>。我们在 Shadow DOM 中使用变量来指定样式，比如：<code>background-color: var(--bg-colour, #0F0);</code>，这样就可以在 Shadow DOM 外面指定 <code>--bg-colour</code> 变量来设置样式了，如果没有指定变量，将使用默认的样式颜色 <code>#0F0</code>。</p>\n<p>有时我们需要在 Shadow DOM 内部使用完全自定义的样式，比如字体样式、字体大小，如果任由其继承可能导致布局错乱，而每次在组件外面指定样式又略显麻烦，并且也破坏了组件的封装性。所以，Shadow DOM 提供了一个 <code>all</code> 属性，只要指定 <code>:host{ all: initial; }</code> 就可以重置所有继承的属性。</p>\n<blockquote>\n<h3>Demo</h3>\n<p>Web Components 的 Demo 在网上已经有很多了，这是我 2 年前初次接触 ES6 与 Web Components 的时候写的一个 Demo：<a href="https://github.com/jinliming2/Calendar-js">https://github.com/jinliming2/Calendar-js</a>，一个日历，当时还是 v0 的规范，并且在 Firefox 下还存在会导致 Firefox 崩溃的 Bug（感觉是 Firefox 在实现 Shadow DOM 时的 Bug）。目前这个 Demo 已经不能在 Firefox 下运行了，因为 Firefox 已经删除了 v0 规范，开始实行 v1 标准了，所以近期我可能会重构一下这个 Demo。</p>\n</blockquote>\n<h1>总结</h1>\n<p><a href="https://github.com/w3c/webcomponents">Web Components</a> 的概念最初是由 <a href="https://twitter.com/slightlylate">Alex Russell</a> 在 <a href="https://fronteers.nl/congres/2011/sessions/web-components-and-model-driven-views-alex-russell">Fronteers Conference 2011</a> 提出的，这个概念在当时非常的震撼。2013 年，Google 推出了一个叫做“<a href="https://en.wikipedia.org/wiki/Polymer_(library)">Polymer</a>”的 Web Components 框架以推动 Web Components 的发展。</p>\n<p>2014 年，Chrome 发布了早期版本的 Web Components 组件规范，包括 Custom Elements v0、Shadow DOM v0 和 HTML Imports。但是此时的规范都还是实验性的，现在已经不推荐使用，并且被 Custom Elements v1、Shadow DOM v1 标准取代，而 HTML Imports 却没有标准化，将来会被 ES6 Modules 所取代。</p>\n<p>v0 规范将会在 Chrome 70 中被标记弃用警告，并在 2019 年 3 月左右从 Chrome 73 中删除。</p>\n<p>而 v1 标准已经在 Chrome 54+ 和 Safari 10.1+ 中支持，并计划本月（2018 年 10 月）在 Firefox 中正式支持（此前 Firefox 已经支持，但默认禁用，需要在 <a href="about:config">about:config</a> 中启用）。</p>\n<p>而 HTML Templates 作为 HTML5 的功能早已被各大浏览器接受并支持。</p>\n<blockquote>\n<p>由于 Web Components 涉及到的子项较多，这里就不给出 Can I Use 的截图了，读者可以自行去搜索“Web Components”查看相关兼容性，或是<a href="https://caniuse.com/#search=Web%20Components">点击这里</a>。</p>\n<p>Can I Use 中包含了 <a href="https://caniuse.com/#feat=template">HTML Templates</a>、<a href="https://caniuse.com/#feat=imports">HTML Imports</a>、<a href="https://caniuse.com/#feat=shadowdomv1">Shadow DOM v0</a>、<a href="https://caniuse.com/#feat=custom-elements">Custom Elements v0</a>、<a href="https://caniuse.com/#feat=shadowdomv1">Shadow DOM v1</a> 和 <a href="https://caniuse.com/#feat=custom-elementsv1">Custom Elements v1</a> 的相关浏览器兼容性和注释，非常详细。</p>\n</blockquote>\n<p>原生 HTML 组件基于的 Web Components 不是单一的技术，他是由 W3C 定义的一系列浏览器标准组成的，通过浏览器自身可以理解的方式去构建组件，这将成为未来的前端标准。</p>',
fields:{slug:"/2018-10-05-ni-ting-shuo-guo-yuan-sheng-html-zu-jian-ma/"},frontmatter:{title:"你听说过原生 HTML 组件吗？",date:"2018-10-05",catalog:"前沿新兴",author:"jinliming2"}},allMarkdownRemark:{edges:[{node:{fields:{slug:"/2018-03-25-ru-he-xie-yi-ge-gao-bi-ge-readme/howToWrite/"},frontmatter:{title:""}}},{node:{fields:{slug:"/2018-10-11-yi-ni-er-duo-li-you-tiao-yu/"},frontmatter:{title:"【译】你耳朵里有条鱼"}}},{node:{fields:{slug:"/2018-10-07-dapp-dev-practice/"},frontmatter:{title:"区块链上编程：DApp 开发实践"}}},{node:{fields:{slug:"/2018-10-05-ni-ting-shuo-guo-yuan-sheng-html-zu-jian-ma/"},frontmatter:{title:"你听说过原生 HTML 组件吗？"}}},{node:{fields:{slug:"/2018-09-28-yong-huo-zhuo-de-cnn-jin-hang-yan-zheng-ma-shi-bie/"},frontmatter:{title:"用“活着的”CNN进行验证码识别"}}},{node:{fields:{slug:"/2018-09-27-yi-chao-shi-yong-7-ge-you-xiu-de-ui-jiao-hu-dong-hua-ji-qiao/"},frontmatter:{title:"【译】超实用！7 个优秀的 UI 交互动画技巧"}}},{node:{fields:{slug:"/2018-09-25-guan-yu-http2-de-yan-jiu/"},frontmatter:{title:"关于 HTTP2 的研究"}}},{node:{fields:{slug:"/2018-09-25- heretic-judger-1/"},frontmatter:{title:"异端审判器！一个泛用型文本聚类模型的实现（1）"}}},{node:{fields:{slug:"/2018-09-25-wo-men-ying-gai-zuo-xie-li-suo-neng-ji-de-you-hua/"},frontmatter:{title:"我们应该做些力所能及的优化"}}},{node:{fields:{slug:"/2018-09-25-twenty-to-fifty-years-programming/"},frontmatter:{title:"【译】有哪些事情是编程 20 到 50 多年后才知道的？"}}},{node:{fields:{slug:"/2018-09-19-yi-yu-yong-hu-lian-xi-zai-wang-ye-she-ji-zhong-rong-ru-you-mo/"},frontmatter:{title:"【译】与用户联系：在网页设计中融入幽默"}}},{node:{fields:{slug:"/2018-09-19-yi-ru-he-she-ji-geng-hao-de-shu-ju-biao/"},frontmatter:{title:"【译】如何设计更好的数据表"}}},{node:{fields:{slug:"/2018-09-13-yi-dao-shi-jian-xun-huan-ti-yin-fa-de-xie-an/"},frontmatter:{title:"一道事件循环题引发的血案"}}},{node:{fields:{slug:"/2018-09-12-qian-duan-gong-cheng-hua-jiao-shou-jia/"},frontmatter:{title:"前端工程化：脚手架"}}},{node:{fields:{slug:"/2018-09-12-qian-tan-vue-zhong-computed-shi-xian-yuan-li/"},frontmatter:{title:"浅谈 Vue 中 computed 实现原理"}}},{node:{fields:{slug:"/2018-08-31-jian-shu-da-shu-ju-shi-shi-chu-li-kuang-jia/"},frontmatter:{title:"简述大数据实时处理框架"}}},{node:{fields:{slug:"/2018-08-22-shen-ru-promise/"},frontmatter:{title:"深入Promise"}}},{node:{fields:{slug:"/2018-08-13-tcp-lian-jie-ji-chang-jian-gong-ji-shou-fa-fen-xi/"},frontmatter:{title:"要点梳理：TCP连接及常见攻击手法分析"}}},{node:{fields:{slug:"/2018-08-13-ran-bing-luan-bf-ke-pu-bf-jie-shi-qi-de-js-shi-xian/"},frontmatter:{title:"然并卵：BF 科普 & BF 解释器的 JS 实现"}}},{node:{fields:{slug:"/2018-08-10-dapp-kai-fa-jian-jie/"},frontmatter:{title:"DApp 开发简介"}}},{node:{fields:{slug:"/2018-08-09-shi-lian-zhi-shi-performance/"},frontmatter:{title:"试炼之石-Performance"}}},{node:{fields:{slug:"/2018-08-09-prolog/"},frontmatter:{title:"那迷人的被遗忘的语言：Prolog"}}},{node:{fields:{slug:"/2018-08-08-qiao-qiao-xian-qi-webassembly-de-shen-mi-mian-sha/"},frontmatter:{title:"悄悄掀起 WebAssembly 的神秘面纱"}}},{node:{fields:{slug:"/2018-04-16-fan-yi-2018-nian-12-zhong-yi-dong-duan-yong-hu-ti-yan-she-ji-qu-shi/"},frontmatter:{title:"【翻译】2018 年 12 种移动端用户体验设计趋势"}}},{node:{fields:{slug:"/2018-04-08-fan-yi-mei-ge-uiux-she-ji-shi-du-xu-yao-zhi-dao-de-xin-li-xue-yuan-li/"},frontmatter:{title:"【翻译】每个 UI / UX 设计师都需要知道的心理学原理"}}},{node:{fields:{slug:"/2018-04-07-fan-yi-yan-fa-ren-yuan-de-sheng-chan-li-shi-fou-ke-yi-liang-hua/"},frontmatter:{title:"【翻译】研发人员的生产力是否可以量化"}}},{node:{fields:{slug:"/2018-04-01-fan-yi-jie-he-tu-xing-he-yu-yin-jie-mian-ti-gong-geng-hao-de-yong-hu-ti-yan/"},frontmatter:{title:"【翻译】结合图形和语音界面，提供更好的用户体验"}}},{node:{fields:{slug:"/2018-03-31-fan-yi-http1-dao-http2-de-yan-bian-ru-he-gai-bian-liao-web/"},frontmatter:{title:"【译】HTTP1 到 HTTP 2 的演变如何改变了 web"}}},{node:{fields:{slug:"/2018-03-28-shui-dong-liao-wo-de-dom/"},frontmatter:{title:"谁动了我的 DOM？！"}}},{node:{fields:{slug:"/2018-03-27-fan-yi-wei-kai-yuan-ruan-jian-she-ji/"},frontmatter:{title:"【翻译】为开源软件设计"}}},{node:{fields:{slug:"/2018-03-27-fan-yi-nodejstwofactor-shen-fen-ren-zheng/"},frontmatter:{title:"【译】node.js Two-Factor 身份认证"}}},{node:{fields:{slug:"/2018-03-25-react-server-side-render-with-hapi/"},frontmatter:{title:"服务端渲染和静态化"}}},{node:{fields:{slug:"/2018-03-25-ru-he-xie-yi-ge-gao-bi-ge-readme/"},frontmatter:{title:"如何写一个高逼格 README"}}},{node:{fields:{slug:"/2018-03-25-quan-zhan-gong-cheng-shi-zhi-lu-reactnative-zhi-sao-miao-er-wei-ma/"},frontmatter:{title:"全栈工程师之路-React Native之扫描二维码"}}},{node:{fields:{slug:"/2018-03-22-wu-xian-wang-luo-ling-lei-xiu-tan/"},frontmatter:{title:"无线网络另类嗅探"}}},{node:{fields:{slug:"/2018-03-19-fan-yi-shi-yong-de-ui-dong-hua-ji-qiao-gai-jin-ui-wei-jiao-hu-de-shi-yong-jian-yi/"},frontmatter:{title:"【翻译】实用的 UI 动画技巧——改进 UI 微交互的实用建议"}}},{node:{fields:{slug:"/2018-03-19-reactref-zhi-bei-jiao-cheng/"},frontmatter:{title:"React ref 指北教程"}}},{node:{fields:{slug:"/2018-03-18-fan-yi-how-to-prevent-your-node.js-process-from-crashing/"},frontmatter:{title:"【翻译】 如何使你的 Node 应用免于崩溃"}}},{node:{fields:{slug:"/2018-03-17-yi-zhong-qian-hou-duan-fen-li-de-kua-yu-kai-fa-fang-shi/"},frontmatter:{title:"一种方便的跨域开发解决方案"}}},{node:{fields:{slug:"/2018-03-16-yuan-chuang-ji-yu-babylonjs-shi-xian-3d-da-ji-xiao-guo/"},frontmatter:{title:"基于 Babylon.js 实现 3D 打击效果"}}},{node:{fields:{slug:"/2018-03-13-fan-yi-ru-he-chuang-jian-jiao-hu-you-hao-de-biao-dan/"},frontmatter:{title:"【译】如何创建交互友好的表单"}}},{node:{fields:{slug:"/2018-03-12-fan-yi-rang-wo-men-cong-ling-kai-shi-bian-bian-xie-yi-ge-web-fu-wu-qi/"},frontmatter:{title:"【译】让我们从零开始编写一个web服务器"}}},{node:{fields:{slug:"/2018-03-11-bikeshedding/"},frontmatter:{title:"由屎色自行车棚引发的思考"}}},{node:{fields:{slug:"/2018-03-11-xin-shou-shi-jiao-de-docker/"},frontmatter:{title:"新手视角的 Docker"}}},{node:{fields:{slug:"/2018-03-07-fan-yi-ji-yu-cypress-ce-shi-react-ying-yong/"},frontmatter:{title:"【译】基于 Cypress 测试 React 应用"}}},{node:{fields:{slug:"/2018-03-05-fan-yi-ru-he-zhao-dao-wan-mei-de-se-cai-da-pei-jie-shao-colorclaim/"},frontmatter:{title:"【译】如何找到完美的色彩搭配 - 介绍 ColorClaim"}}},{node:{fields:{slug:"/2018-03-05-ru-he-shi-yong-mac-po-jie-wifi/"},frontmatter:{title:"如何使用Mac破解Wifi"}}},{node:{fields:{slug:"/2018-03-05-yi-ge-chrome-kuo-zhan-jiu-zhe-yang-dan-sheng-liao/"},frontmatter:{title:"程序员偷懒指南——用chrome插件实现前端资讯推送"}}},{node:{fields:{slug:"/2018-03-01-wei-xian-de-targetblank-yu-opener/"},frontmatter:{title:'危险的 target="_blank" 与 “opener”'}}},{node:{fields:{slug:"/2018-02-28-activerecord-he-datamappers-mo-shi-jian-jie/"},frontmatter:{title:"Active Record 和 Data Mappers 模式简介"}}},{node:{fields:{slug:"/2018-02-26-bu-jin-jin-shi-piao-liang-tu-xiang-ru-he-qu-dong-yong-hu-ti-yan/"},frontmatter:{title:"【译】不仅仅是漂亮：图像如何驱动用户体验"}}},{node:{fields:{slug:"/2018-02-23-css3-clip-path-yong-fa-jie-shao/"},frontmatter:{title:"CSS3 clip-path 用法介绍"}}},{node:{fields:{slug:"/2018-02-23-du-shu-bi-ji-ke-shi-hua-shi-yi-zhong-yi-shu-bu-zhi-shi-mei-xin-xi-tu-biao-she-ji-yuan-li-yu-jing-dian-an-li-xu-zhang/"},frontmatter:{title:"读书笔记：可视化是一种艺术 -《不只是美：信息图表设计原理与经典案例》序章"}}},{node:{fields:{slug:"/2018-02-23-mei-ge-node-ying-yong-ke-neng-cun-zai-de-timing-attack-an-quan-lou-dong/"},frontmatter:{title:"每个 node 应用可能存在的 timing-attack 安全漏洞"}}},{node:{fields:{slug:"/2018-02-09-zan-lai-liao-liao-vuecompile/"},frontmatter:{title:"咱来聊聊 Vue - compile"}}},{node:{fields:{slug:"/2018-02-05-ji-yi-ci-jian-dan-de-csrf-gong-ji-shi-yan/"},frontmatter:{title:"记一次简单的 CSRF 攻击实验"}}},{node:{fields:{slug:"/2018-02-04-fan-yi-reactscope-jie-shao/"},frontmatter:{title:"【译】React Scope介绍"}}},{node:{fields:{slug:"/2018-02-03-fan-yi-liu-ge-xuan-ze-ui-yan-se-de-ji-qiao/"},frontmatter:{title:"【译】六个选择UI颜色的技巧"}}},{node:{fields:{slug:"/2018-02-03-huo-yong-git-apply-he-ru-patch-bu-ding/"},frontmatter:{title:"活用 git apply 合入 patch 补丁"}}},{node:{fields:{slug:"/2018-02-03-wo-de-di-yi-ge-node-ming-ling-hang-gong-ju/"},frontmatter:{title:"我的第一个 Node 命令行工具"}}},{node:{fields:{slug:"/2018-02-01-fan-yi-react-xin-de-contextapi/"},frontmatter:{title:"【译】React ⚛️  新的 Context API"}}},{node:{fields:{slug:"/2018-01-29-kuai-su-da-jian-ni-de-github-page-ge-ren-bo-ke-ji-yu-createreactapp-de-dan-ye-mian-ying-yong-shi-jian/"},frontmatter:{title:"快速搭建你的 github pages 个人博客 —— 基于 Create-React-App 的单页面应用实践"}}},{node:{fields:{slug:"/2018-01-28-redux-promise-middleware/"},frontmatter:{title:"一个插件让你在 Redux 中写 promise 事半功倍"}}},{node:{fields:{slug:"/2018-01-28-fan-yi-react-zu-jian-mo-shi/"},frontmatter:{title:"【译】React 组件设计模式基础"}}},{node:{fields:{slug:"/2018-01-28-fan-yi-bu-yao-rang-yong-hu-zai-chan-pin-ti-yan-shang-shou-dao-cuo-zhe/"},frontmatter:{title:"【译】不要让用户在产品体验上受到挫折"}}},{node:{fields:{slug:"/2018-01-27-javascript-mo-huan-dai-li/"},frontmatter:{title:"JavaScript 魔幻代理"}}},{node:{fields:{slug:"/2018-01-22-web-qian-duan-jian-dan-ding-yue-de-shi-xian/"},frontmatter:{title:"Web前端简单订阅的实现"}}},{node:{fields:{slug:"/2018-01-21-how-django-works/"},frontmatter:{title:"从请求到响应 django 都做了哪些处理"}}},{node:{fields:{slug:"/2018-01-21-electron-with-react/"},frontmatter:{title:"React+Electron搭建一个桌面应用"}}},{node:{fields:{slug:"/2018-01-20-fan-yi-ui-she-ji-zhong-de-ge-shi-ta-yuan-ze/"},frontmatter:{title:"【译】UI 设计中的格式塔原则"}}},{node:{fields:{slug:"/2018-01-19-xia-yi-dai-tong-xin-xie-yi-quic/"},frontmatter:{title:"下一代通信协议：QUIC"}}},{node:{fields:{slug:"/2018-01-19-fan-yi-shi-yong-css-zhui-zong-yong-hu/"},frontmatter:{title:"【译】使用 CSS 追踪用户"}}},{node:{fields:{slug:"/2018-01-14-antd-yuan-ma-jie-du-notification/"},frontmatter:{title:"antd 源码解读 notification"}}},{node:{fields:{slug:"/2018-01-14-ui-zhong-de-pai-ban-chu-xue-zhe-zhi-nan/"},frontmatter:{title:"【译】UI 中的排版：初学者指南"}}},{node:{fields:{slug:"/2018-01-14-learn-koa-intro/"},frontmatter:{title:"koa包教包会(一)——白话koa"}}},{node:{fields:{slug:"/2018-01-13-zi-ji-dong-shou-xie-yi-ge-simplevue/"},frontmatter:{title:"自己动手写一个 SimpleVue"}}},{node:{fields:{slug:"/2018-01-12-translation-React-Animations-in-Depth/"},frontmatter:{title:"【译】React Web 动画的 5 种创建方式，每一种都不简单"}}},{node:{fields:{slug:"/2018-01-10-ru-he-kuo-zhan-create-react-app-de-webpack-pei-zhi/"},frontmatter:{title:"如何扩展 Create React App 的 Webpack 配置"}}},{node:{fields:{slug:"/2018-01-08-mapbox-gl-js/"},frontmatter:{title:"3D GIS 应用开发 —— 基于 Mapbox GL 的实践总结"}}},{node:{fields:{slug:"/2018-01-07-the-importance-of-visual-appeal-in-web-design/"},frontmatter:{title:"【译】视觉吸引力在网页设计中的重要性"}}},{node:{fields:{slug:"/2018-01-06-react-higher-order-component/"},frontmatter:{title:"React 高阶组件介绍"}}},{node:{fields:{slug:"/2018-01-05-to-vim/"},frontmatter:{title:"如何让 vim 成为我们的神器"}}},{node:{fields:{slug:"/2018-01-05-d3-js-v3-data-driven-and-d3-force/"},frontmatter:{title:"D3.js 数据驱动 和 force 力学图讲解"}}},{node:{fields:{slug:"/2018-01-05-create-a-redux-middleware/"},frontmatter:{title:"如何编写一个 Redux 中间件"}}}]}},pathContext:{slug:"/2018-10-05-ni-ting-shuo-guo-yuan-sheng-html-zu-jian-ma/"}}}});
//# sourceMappingURL=path---2018-10-05-ni-ting-shuo-guo-yuan-sheng-html-zu-jian-ma-450c7af712565aec7a89.js.map