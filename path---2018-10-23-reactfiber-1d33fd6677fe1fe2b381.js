webpackJsonp([21785187991795],{679:function(e,n){e.exports={data:{site:{siteMetadata:{title:"创宇前端 - 最酷开发者的技术分享",author:"KnownsecFED",siteUrl:"https://knownsec-fed.com"}},markdownRemark:{id:"/tmp/app/src/pages/2018-10-23-reactfiber/index.md absPath of file >>> MarkdownRemark",html:'<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/header-11ea97c36869e5a3314f5c140d2d1b6d-7930b.jpeg"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 1200px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 53.691275167785236%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHArjaiwF//xAAZEAADAQEBAAAAAAAAAAAAAAABAgMQETH/2gAIAQEAAQUCHtYmY5jUZ8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAZEAADAAMAAAAAAAAAAAAAAAABEBEAIjH/2gAIAQEABj8CwcexsX//xAAZEAEAAwEBAAAAAAAAAAAAAAABABFBECH/2gAIAQEAAT8hCgC1yOHoXMluUVuHP//aAAwDAQACAAMAAAAQXw//xAAWEQADAAAAAAAAAAAAAAAAAAABEBH/2gAIAQMBAT8QNX//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPxAn/8QAHhABAAIBBAMAAAAAAAAAAAAAAQARQRAhMVFhcfD/2gAIAQEAAT8QJwgBZY1F0KUtXG77nQXoh5wY+qKrbP/Z\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="React Fiber"\n        title=""\n        src="/static/header-11ea97c36869e5a3314f5c140d2d1b6d-d6978.jpeg"\n        srcset="/static/header-11ea97c36869e5a3314f5c140d2d1b6d-527f0.jpeg 300w,\n/static/header-11ea97c36869e5a3314f5c140d2d1b6d-9a7cd.jpeg 600w,\n/static/header-11ea97c36869e5a3314f5c140d2d1b6d-d6978.jpeg 1200w,\n/static/header-11ea97c36869e5a3314f5c140d2d1b6d-7930b.jpeg 1490w"\n        sizes="(max-width: 1200px) 100vw, 1200px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h1>React Fiber</h1>\n<h2>Diff 算法</h2>\n<p>熟悉 react 的朋友都知道，在 react 中有个核心的算法，叫 diff 算法。web 界面由 dom 树组成，不同的 dom 树会渲染出不同的界面。react 使用 virtual dom 来表示 dom 树，而 diff 算法就是用于比较 virtual dom 树的区别，并更新界面需要更新的部分。diff 算法和 virtual dom 的完美结合的过程被称为 reconciler，这可是 react 攻城拔寨的绝对利器。有了 reconciler，开发者可以脱身操作真实的 dom 树，只需要向 react 描述界面的状态，而 react 会帮助你高效的完成真正 dom 操作。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/reconciler-d8d7812617894d5c10b9da6816e4be89-8bb97.jpeg"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 596px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 56.04026845637584%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHurE0hf//EABYQAAMAAAAAAAAAAAAAAAAAAAABIP/aAAgBAQABBQIc/wD/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAXEAEAAwAAAAAAAAAAAAAAAAABECCB/9oACAEBAAE/IXaFj//aAAwDAQACAAMAAAAQxw//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAZEAEBAQEBAQAAAAAAAAAAAAABEQBBITH/2gAIAQEAAT8QZWvg4uQxrORmPmuYk7rPDf/Z\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="React Diff"\n        title=""\n        src="/static/reconciler-d8d7812617894d5c10b9da6816e4be89-8bb97.jpeg"\n        srcset="/static/reconciler-d8d7812617894d5c10b9da6816e4be89-5fe18.jpeg 300w,\n/static/reconciler-d8d7812617894d5c10b9da6816e4be89-8bb97.jpeg 596w"\n        sizes="(max-width: 596px) 100vw, 596px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>在 react16 之前的 reconciler 叫 stack reconciler，fiber 是 react 新的 reconciler，这次更新到 fiber 架构是一次重量级的核心架构的替换，react 为了完成这次替换已经准备了两三年的时间了。</p>\n<p>那么 fiber 究竟有什么好的呢？</p>\n<h2>Fiber 为何出现</h2>\n<p>不知道大家有没有遇到过这样的情况，点击一个页面的按钮时感觉到页面没有任何的反应，让你怀疑电脑是不是死机了，然后你快速切出浏览器，发现电脑并没有死机，于是再切回浏览器，这时候才发现页面终于更新了。为什么会出现这种情况？在多数情况下，可能是因为浏览器忙着执行相关的 js 代码，导致浏览器主线程没有及时响应用户的操作或者没有及时更新界面。下面这张图就表示了这种现象，你的公司只有一个程序员 (main thread)，当这个程序员在执行你的任务 (your code) 时，处于沉浸式编程的状态，无法响应外部的其他事件，什么下班吃饭，都是不存在的。这就像浏览器忙着执行 js 代码的时候，不会去执行页面更新等操作。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/mainthread-eb46d69eaaeb4f2644082b4cf6525fb8-db9b4.jpeg"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 827px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 68.19830713422007%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAACBklEQVQ4y21T2XKbQBDk/78mr8lDSnEpqVSq7DiHY1kHsrhkxC2OBRbozKy0GMkuaqRlp+nt6Zk1evQ41jVSIVR0Q6eC96/X0z1JEZUVwqJCQNH2UuUN/qlki0ycSIGB4pVg+mgyjWGynMSwINmf8AYDhvMHZdvgOSrxchQj6bUyxjpJRZgKTSfVOyYHGnoBVXqDdVDADHMIUj1MiDQmFQ12cUm4HLWUb6wxpidXBHjwMqXyPQ+ZsGolLCJ00+rCljeE2ptvmxj7rFJrOcnp4Co+3Pu4WYaq5P6qirFkVphQObe7GH/cdAT3Z4903O4ifDdjOjjENjwC6uhXH42pPzaZ/fHhgE//fKWOgUzsU5OissGhqDEjZfN1RP8R7qwEWc37An4uaHS6y5IHemZPIXWxVOdqX+ykwOLlqJrhZEIRrg45vRcq/nopnLRUAi6aUpOaH9v4qhEDChonNy3O8zfgZhXSiLVjqZzjkcN7XZ6vgguz9ThpQsbN1yHSqh593WclvZ9m99yUXgEFEX4lMHsxTBTmjSaEwvy0UwS5GA+wk3xUbLRdC46O7mJBV2i28CFIvuxbUtqiHySiooQZpETQISMlnx99GupGfcf5zSFB2fD1kzBs1waHQ7FzLHy5f8LWtuB4Nizacz0Hj+YWv5YmvL2DZ8rdLTYqZ6u8jfnvJRaEYex/PVk6QlsvCWAAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="mainthread"\n        title=""\n        src="/static/mainthread-eb46d69eaaeb4f2644082b4cf6525fb8-db9b4.jpeg"\n        srcset="/static/mainthread-eb46d69eaaeb4f2644082b4cf6525fb8-39fc2.jpeg 300w,\n/static/mainthread-eb46d69eaaeb4f2644082b4cf6525fb8-7b038.jpeg 600w,\n/static/mainthread-eb46d69eaaeb4f2644082b4cf6525fb8-db9b4.jpeg 827w"\n        sizes="(max-width: 827px) 100vw, 827px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>本着顾客是上帝的原则，作为一名优秀的开发者，怎么能够允许出现这种情况降低用户的体验呢。因此 react 团队引入了异步渲染这个概念，而采用 fiber 架构可以实现这种异步渲染的方式。</p>\n<p>原先的 stack reconciler 像是一个递归执行的函数，从父组件调用子组件的 reconciler 过程就是一个递归执行的过程，这也是为什么被称为 stack reconciler 的原因。当我们调用 setState 的时候，react 从根节点开始遍历，找出所有的不同，而对于特别庞大的 dom 树来说，这个递归遍历的过程会消耗特别长的时间。在这个期间，任何交互和渲染都会被阻塞，这样就给用户一种“死机”的感觉。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/stackreconciler-e90e3cd4afad3fe3a0684ce14865d195-87f44.jpeg"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 664px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 62.951807228915655%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAABg0lEQVQ4y6WT2U7DMBBF8/9fwV8gEBJPqCoSAlEQ9KE7Sbc0S5M4i5fLjJOUtOoDUEsnHsfx9fVk7GhjUEqNthkaX9KcTSLgRhnivITS5iD6H6xgKRUqZRCLggT1Re5Y1AnSgiIgIkFRSXt83oT7gqka5DF5xSiLKNUhbU5/ssPTLEChNOKiQlrImrJFnfQ1GZE033Gfkwl25rDq/XADPyuR0KJAVAiFRJQTFEd5TShKoh3zvCKnhk6lkTUn4Cxawed5gM/V3u4iKY/SaOu4RlkUVwONBR0xo43Z1c37EjM/xXibYB3n9ZH5sdkX6I19XL956E934DTMA4HZLsNXmGFBMb9b0qKXRYir3hQPIx+3HyuMSHC4TuCnZS3YrTtOrEcCj5MtXt0IAzckIityR4sHbmzz7UWiydmZv9wGbQ16Ufrr8jG0RjdwzEl0TgvzK0hs+fBk92OtfuIjTHMRdMdh98pt6eZwHbKgOSfQutHtPCw8tg67V42bpD/Z2rfvDP7ENysU+EKD4yaKAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="stackreconciler"\n        title=""\n        src="/static/stackreconciler-e90e3cd4afad3fe3a0684ce14865d195-87f44.jpeg"\n        srcset="/static/stackreconciler-e90e3cd4afad3fe3a0684ce14865d195-7d030.jpeg 300w,\n/static/stackreconciler-e90e3cd4afad3fe3a0684ce14865d195-19d09.jpeg 600w,\n/static/stackreconciler-e90e3cd4afad3fe3a0684ce14865d195-87f44.jpeg 664w"\n        sizes="(max-width: 664px) 100vw, 664px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>fiber 的出现解决了这个问题，它把 reconciler 的过程拆分成了一个个的小任务，并在完成了小任务之后暂停执行 js 代码，然后检查是否有需要更新的内容和需要响应的事件，做出相应的处理后再继续执行 js 代码。这样就给了用户一种应用一直在运行的感觉，提高了用户的体验。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/fiberreconciler-cf0ee9cf8c460da97f5a377b5d6b6267-8598e.jpeg"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 654px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 53.82262996941897%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABoUlEQVQoz5WT607CQBCFef+HUaMRQYJXQI2Jd4tSEAL0yoJiC63dbo8z2yLEXzrJdmd3zn5zmm5L2Igsy37mME6g1HoNTv8wSlIpzKMvqA0YhzULkEilRZn6B1CEEez5AiKMEcsUzGP4QHziK0m1iJ0yVP0a2a9cAwNyxxElSdEmDxEu8d9gaIlddP0Ag2kI0/vEcLpAX4R4st7Rn4R63aO6/RGh65GOajxMyq33pdbwGJGOo8QPFrTeBLZuh6g+29h/tLB7P8LBk4Va28Gh4eCC6tu3I5Rpr0z1nbsxLvuCNDaaXR8iiNbAMJY47fgEGmsgA/YexjjpeKi/uDg3fZyZXt7AcEnj4OjVRYNAR1RvUj1O5BoYRJIO+NoZC2uGjSpBee/klaDkkl2UqWGjO9FNeV1vu2QkBy/iZMMhAbkT22cnFTrAr8qvxw55zfBjasYNKqTjpis97+cflYCre8fAm+EMzZ6P68EUrd6Eunu46k9oLbQjw/ko9oTeZ1DbndNZZ/2VV0CZZvr+pSqff+5XkadpMdOPoOsbWpkWPwDl35U4PZzcQWkKAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="fiberreconciler"\n        title=""\n        src="/static/fiberreconciler-cf0ee9cf8c460da97f5a377b5d6b6267-8598e.jpeg"\n        srcset="/static/fiberreconciler-cf0ee9cf8c460da97f5a377b5d6b6267-56405.jpeg 300w,\n/static/fiberreconciler-cf0ee9cf8c460da97f5a377b5d6b6267-e150f.jpeg 600w,\n/static/fiberreconciler-cf0ee9cf8c460da97f5a377b5d6b6267-8598e.jpeg 654w"\n        sizes="(max-width: 654px) 100vw, 654px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2>Fiber 如何做到异步渲染</h2>\n<p>在做显示方面的工作时，经常会听到一个目标叫 60 帧，这表示的是画面的更新频率，也就是画面每秒钟更新 60 次。这是因为在 60 帧的更新频率下，页面在人眼中显得流畅，无明显卡顿。每秒钟更新 60 次也就是每 16ms 需要更新一次页面，如果更新页面消耗的时间不到 16ms，那么在下一次更新时机来到之前会剩下一点时间执行其他的任务，只要保证及时在 16ms 的间隔下更新界面就完全不会影响到页面的流畅程度。fiber 的核心正是利用了 60 帧原则，实现了一个基于优先级和 requestIdleCallback 的循环任务调度算法。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/requestIdleCallback-18eba080f1aa2a3ddaa538b4827158e1-50b73.jpeg"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 731px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 35.02051983584131%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABKElEQVQoz3WRTUvDQBCG+98FwYP+AE+e9KJ4UCiCBcUeRBEtrXowNi1NS9I0m20akzT78TrbfDSiDjzsu8vMOzu7rSxLwRiD1tiErkSpq32lm5iI4xU453VOSwiBJEn+LFANmmG21VGeC6RpBl0Z/kz9P5SMkK0X0MrcZlkSkUlkrOq8lmm1iDIMvRUmQYJpmGLsx3BI226EobuE7afwrBuMuoeYPx8jsc4QvZ+C90+QjNpwOdX6X5BSkSG5f3oxrnsz3H8EeLI57t48PFgMnReHmKAz8DHtXcJr72J8sYf57QFmV/uwz3cQPh6h7zB0X12sc0kj0w2llPWjKqWKEcu1HlnQaDIgEUILRprQIZ0zqhfbT6lMjKlBlesvlGmMAoWt3lDkGK9vhpAaQTxAWPYAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="requestIdleCallback"\n        title=""\n        src="/static/requestIdleCallback-18eba080f1aa2a3ddaa538b4827158e1-50b73.jpeg"\n        srcset="/static/requestIdleCallback-18eba080f1aa2a3ddaa538b4827158e1-a02a6.jpeg 300w,\n/static/requestIdleCallback-18eba080f1aa2a3ddaa538b4827158e1-e19a1.jpeg 600w,\n/static/requestIdleCallback-18eba080f1aa2a3ddaa538b4827158e1-50b73.jpeg 731w"\n        sizes="(max-width: 731px) 100vw, 731px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>requestIdleCallback 是浏览器提供的一个 api，可以让浏览器在空闲的时候执行回调，在回调参数中可以获取到当前帧剩余的时间，fiber 利用了这个参数，判断当前剩下的时间是否足够继续执行任务，如果足够则继续执行，否则暂停任务，并调用 requestIdleCallback 通知浏览器空闲的时候继续执行当前的任务。</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fiber</span><span class="token punctuation">(</span>剩余时间<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n <span class="token keyword">if</span> <span class="token punctuation">(</span>剩余时间 <span class="token operator">></span> 任务所需时间<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n 做任务<span class="token punctuation">;</span>\n <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n <span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>\n <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>fiber 还会为不同的任务设置不同的优先级，高优先级任务是需要马上展示到页面上的，比如你正在输入框中输入文字，你肯定希望你的手指在键盘上敲下每一个按键时，输入框能立马做出反馈，这样你才能知道你的输入是否正确，是否有效。低优先级的任务则是像从服务器传来了一些数据，这个时候需要更新页面，比如这篇文章喜欢的人数+1 或是评论+1，这并不是那么紧急的更新，延迟 100-200ms 并不会有多大差别，完全可以在后面进行处理。fiber 会根据任务优先级来动态调整任务调度，优先完成高优先级的任务。</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token punctuation">{</span> \n Synchronous<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// 同步任务，优先级最高</span>\n Task<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token comment">// 当前调度正执行的任务</span>\n Animation <span class="token number">3</span><span class="token punctuation">,</span> <span class="token comment">// 动画</span>\n High<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token comment">// 高优先级</span>\n Low<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token comment">// 低优先级</span>\n Offscreen<span class="token punctuation">:</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token comment">// 当前屏幕外的更新，优先级最低</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>在 fiber 架构中，有一种数据结构，它的名字就叫做 <code>fiber</code>，这也是为什么新的 reconciler 叫做 fiber 的原因。<code>fiber</code> 其实就是一个 js 对象，这个对象的属性中比较重要的有 <code>stateNode</code>、<code>tag</code>、<code>return</code>、<code>child</code>、<code>sibling</code> 和 <code>alternate</code>。</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code>Fiber <span class="token operator">=</span> <span class="token punctuation">{</span>\n tag <span class="token comment">// 标记任务的进度</span>\n <span class="token keyword">return</span> <span class="token comment">// 父节点</span>\n child <span class="token comment">// 子节点</span>\n sibling <span class="token comment">// 兄弟节点</span>\n alternate <span class="token comment">// 变化记录</span>\n <span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>我们可以看出 <code>fiber</code> 基于链表结构，拥有一个个指针，指向它的父节点子节点和兄弟节点，在 diff 的过程中，依照节点连接的关系进行遍历。</p>\n<h2>fiber 可能存在的问题</h2>\n<p>在 fiber 中，更新是分阶段的，具体分为两个阶段，首先是 reconciliation 的阶段，这个阶段在计算前后 dom 树的差异，然后是 commit 的阶段，这个阶段将把更新渲染到页面上。第一个阶段是可以打断的，因为这个阶段耗时可能会很长，因此需要暂停下来去执行其他更高优先级的任务，第二个阶段则不会被打断，会一口气把更新渲染到页面上。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/hookfunction-b8fa3821391fe30eaf4194064c228e81-97d7d.jpeg"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 604px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 63.0794701986755%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAABh0lEQVQ4y4WT226DMBBE+f8va1Uprao+tVKTQCCAwx1jzG26awK1IpI8DLax97DrHZym11CkslWQXQtgJA0Ypn7VaK2XOY9bct6OMXaewOs+xDuN33GKXClM1wM26BnMAL+CC1gfJ4FPX+CHgN3YEbBHTyNoxrIzfpStU1OZstOodYuKxFeQNAqlrOD6R/jnE6JLBKUbNK0k9PgQ6nBprPnuJjOvtEZDH2JIXuWom8oEccZ28AK3r8PhB2+keYITZeP6LsIoMMEMLAgokhhB6CMUIQ7uHh6d8WnNMTZ0BfKiG/RaVtspA2TpvjXvpKqv+7VZK1JHe5NVsgHad8BfW3TvvR57RJVEVEu4WYmwrLcz3Org0uFpPmHumf36QhbbeTFeD6GZC4LDBt6KAVxWKM7Iy8w0hctlZeTRRFLJfYfZIa35McZnQElAbkZEjWCo7mcrFa3G4gxbS6xzz/HckEqWSLKLAYtUmACsPhz+ZRubbXGrsi5mGwWescn++GvslBUpts7b+gMy+vPsPjKhJgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="hookfunction"\n        title=""\n        src="/static/hookfunction-b8fa3821391fe30eaf4194064c228e81-97d7d.jpeg"\n        srcset="/static/hookfunction-b8fa3821391fe30eaf4194064c228e81-e5064.jpeg 300w,\n/static/hookfunction-b8fa3821391fe30eaf4194064c228e81-25fd3.jpeg 600w,\n/static/hookfunction-b8fa3821391fe30eaf4194064c228e81-97d7d.jpeg 604w"\n        sizes="(max-width: 604px) 100vw, 604px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>由于 reconciliation 的阶段会被打断，可能会导致 commit 前的这些生命周期函数多次执行。react 官方目前已经把 <code>componentWillMount</code>、<code>componentWillReceiveProps</code> 和 <code>componetWillUpdate</code> 标记为 unsafe，并使用新的生命周期函数 <code>getDerivedStateFromProps</code> 和 <code>getSnapshotBeforeUpdate</code> 进行替换。</p>\n<p>还有一个问题是饥饿问题，意思是如果高优先级的任务一直插入，导致低优先级的任务无法得到机会执行，这被称为饥饿问题。对于这个问题官方提出的解决方案是尽量复用已经完成的操作来缓解。相信官方也正在努力提出更好的方法去解决这个问题。</p>',fields:{slug:"/2018-10-23-reactfiber/"},frontmatter:{title:"React Fiber",date:"2018-10-23",catalog:"前沿新兴",author:"Xss"}},allMarkdownRemark:{edges:[{node:{fields:{slug:"/2018-01-07-the-importance-of-visual-appeal-in/kaggle数据实验入门之泰坦尼克号/"},frontmatter:{title:""}}},{node:{fields:{slug:"/2018-03-25-ru-he-xie-yi-ge-gao-bi-ge-readme/howToWrite/"},frontmatter:{title:""}}},{node:{fields:{slug:"/2018-12-13-css-lie-biao-xiang-bu-ju-ji-qiao/"},frontmatter:{title:"CSS 列表项布局技巧"}}},{node:{fields:{slug:"/2018-12-04-ren-gong-zhi-zhang-ye-shua-ti-kaggle-ru-men-zhi-shi-zhan-tai-tan-ni-ke-hao/"},frontmatter:{title:"人工智障也刷题！Kaggle入门之实战泰坦尼克号"}}},{node:{fields:{slug:"/2018-11-16-yi-5-ge-zui-xin-de-yong-hu-ti-yan-she-ji-qu-shi/"},frontmatter:{title:"【译】5 个最新的用户体验设计趋势"}}},{node:{fields:{slug:"/2018-10-23-reactfiber/"},frontmatter:{title:"React Fiber"}}},{node:{fields:{slug:"/2018-10-22-yi-reactnative-yu-ios-jiao-hu/"},frontmatter:{title:"【译】React Native与ios交互"}}},{node:{fields:{slug:"/2018-10-11-yi-ni-er-duo-li-you-tiao-yu/"},frontmatter:{title:"【译】你耳朵里有条鱼"}}},{node:{fields:{slug:"/2018-10-07-dapp-dev-practice/"},frontmatter:{title:"区块链上编程：DApp 开发实践"}}},{node:{fields:{slug:"/2018-10-05-ni-ting-shuo-guo-yuan-sheng-html-zu-jian-ma/"},frontmatter:{title:"你听说过原生 HTML 组件吗？"}}},{node:{fields:{slug:"/2018-09-28-yong-huo-zhuo-de-cnn-jin-hang-yan-zheng-ma-shi-bie/"},frontmatter:{title:"用“活着的”CNN进行验证码识别"}}},{node:{fields:{slug:"/2018-09-27-yi-chao-shi-yong-7-ge-you-xiu-de-ui-jiao-hu-dong-hua-ji-qiao/"},frontmatter:{title:"【译】超实用！7 个优秀的 UI 交互动画技巧"}}},{node:{fields:{slug:"/2018-09-25-guan-yu-http2-de-yan-jiu/"},frontmatter:{title:"关于 HTTP2 的研究"}}},{node:{fields:{slug:"/2018-09-25-yi-android-lu-jing-dong-hua/"},frontmatter:{title:"【译】Android 路径动画"}}},{node:{fields:{slug:"/2018-09-25- heretic-judger-1/"},frontmatter:{title:"异端审判器！一个泛用型文本聚类模型的实现（1）"}}},{node:{fields:{slug:"/2018-09-25-wo-men-ying-gai-zuo-xie-li-suo-neng-ji-de-you-hua/"},frontmatter:{title:"我们应该做些力所能及的优化"}}},{node:{fields:{slug:"/2018-09-25-twenty-to-fifty-years-programming/"},frontmatter:{title:"【译】有哪些事情是编程 20 到 50 多年后才知道的？"}}},{node:{fields:{slug:"/2018-08-24-mongodb-shi-wu/"},frontmatter:{title:"认识 MongoDB 4.0 的新特性——事务（Transactions）"}}},{node:{fields:{slug:"/2018-09-19-yi-yu-yong-hu-lian-xi-zai-wang-ye-she-ji-zhong-rong-ru-you-mo/"},frontmatter:{title:"【译】与用户联系：在网页设计中融入幽默"}}},{node:{fields:{slug:"/2018-09-19-yi-ru-he-she-ji-geng-hao-de-shu-ju-biao/"},frontmatter:{title:"【译】如何设计更好的数据表"}}},{node:{fields:{slug:"/2018-09-13-yi-dao-shi-jian-xun-huan-ti-yin-fa-de-xie-an/"},frontmatter:{title:"一道事件循环题引发的血案"}}},{node:{fields:{slug:"/2018-09-12-qian-duan-gong-cheng-hua-jiao-shou-jia/"},frontmatter:{title:"前端工程化：脚手架"}}},{node:{fields:{slug:"/2018-09-12-qian-tan-vue-zhong-computed-shi-xian-yuan-li/"},frontmatter:{title:"浅谈 Vue 中 computed 实现原理"}}},{node:{fields:{slug:"/2018-09-11-http-de-qian-shi-jin-sheng/"},frontmatter:{title:"HTTP 的前世今生"}}},{node:{fields:{slug:"/2018-08-31-jian-shu-da-shu-ju-shi-shi-chu-li-kuang-jia/"},frontmatter:{title:"简述大数据实时处理框架"}}},{node:{fields:{slug:"/2018-08-22-shen-ru-promise/"},frontmatter:{title:"深入Promise"}}},{node:{fields:{slug:"/2018-08-13-tcp-lian-jie-ji-chang-jian-gong-ji-shou-fa-fen-xi/"},frontmatter:{title:"要点梳理：TCP连接及常见攻击手法分析"}}},{node:{fields:{slug:"/2018-08-13-ran-bing-luan-bf-ke-pu-bf-jie-shi-qi-de-js-shi-xian/"},frontmatter:{title:"然并卵：BF 科普 & BF 解释器的 JS 实现"}}},{node:{fields:{slug:"/2018-08-10-dapp-kai-fa-jian-jie/"},frontmatter:{title:"DApp 开发简介"}}},{node:{fields:{slug:"/2018-08-09-shi-lian-zhi-shi-performance/"},frontmatter:{title:"试炼之石-Performance"}}},{node:{fields:{slug:"/2018-08-09-prolog/"},frontmatter:{title:"那迷人的被遗忘的语言：Prolog"}}},{node:{fields:{slug:"/2018-08-08-qiao-qiao-xian-qi-webassembly-de-shen-mi-mian-sha/"},frontmatter:{title:"悄悄掀起 WebAssembly 的神秘面纱"}}},{node:{fields:{slug:"/2018-04-16-fan-yi-2018-nian-12-zhong-yi-dong-duan-yong-hu-ti-yan-she-ji-qu-shi/"},frontmatter:{title:"【翻译】2018 年 12 种移动端用户体验设计趋势"}}},{node:{fields:{slug:"/2018-04-08-fan-yi-mei-ge-uiux-she-ji-shi-du-xu-yao-zhi-dao-de-xin-li-xue-yuan-li/"},frontmatter:{title:"【翻译】每个 UI / UX 设计师都需要知道的心理学原理"}}},{node:{fields:{slug:"/2018-04-07-fan-yi-yan-fa-ren-yuan-de-sheng-chan-li-shi-fou-ke-yi-liang-hua/"},frontmatter:{title:"【翻译】研发人员的生产力是否可以量化"}}},{node:{fields:{slug:"/2018-04-01-fan-yi-jie-he-tu-xing-he-yu-yin-jie-mian-ti-gong-geng-hao-de-yong-hu-ti-yan/"},frontmatter:{title:"【翻译】结合图形和语音界面，提供更好的用户体验"}}},{node:{fields:{slug:"/2018-03-31-fan-yi-http1-dao-http2-de-yan-bian-ru-he-gai-bian-liao-web/"},frontmatter:{title:"【译】HTTP1 到 HTTP 2 的演变如何改变了 web"}}},{node:{fields:{slug:"/2018-03-28-shui-dong-liao-wo-de-dom/"},frontmatter:{title:"谁动了我的 DOM？！"}}},{node:{fields:{slug:"/2018-03-27-fan-yi-wei-kai-yuan-ruan-jian-she-ji/"},frontmatter:{title:"【翻译】为开源软件设计"}}},{node:{fields:{slug:"/2018-03-27-fan-yi-nodejstwofactor-shen-fen-ren-zheng/"},frontmatter:{title:"【译】node.js Two-Factor 身份认证"}}},{node:{fields:{slug:"/2018-03-25-react-server-side-render-with-hapi/"},frontmatter:{title:"服务端渲染和静态化"}}},{node:{fields:{slug:"/2018-03-25-ru-he-xie-yi-ge-gao-bi-ge-readme/"},frontmatter:{title:"如何写一个高逼格 README"}}},{node:{fields:{slug:"/2018-03-25-quan-zhan-gong-cheng-shi-zhi-lu-reactnative-zhi-sao-miao-er-wei-ma/"},frontmatter:{title:"全栈工程师之路-React Native之扫描二维码"}}},{node:{fields:{slug:"/2018-03-22-wu-xian-wang-luo-ling-lei-xiu-tan/"},frontmatter:{title:"无线网络另类嗅探"}}},{node:{fields:{slug:"/2018-03-19-fan-yi-shi-yong-de-ui-dong-hua-ji-qiao-gai-jin-ui-wei-jiao-hu-de-shi-yong-jian-yi/"},frontmatter:{title:"【翻译】实用的 UI 动画技巧——改进 UI 微交互的实用建议"}}},{node:{fields:{slug:"/2018-03-19-reactref-zhi-bei-jiao-cheng/"},frontmatter:{title:"React ref 指北教程"}}},{node:{fields:{slug:"/2018-03-18-fan-yi-how-to-prevent-your-node.js-process-from-crashing/"},frontmatter:{title:"【翻译】 如何使你的 Node 应用免于崩溃"}}},{node:{fields:{slug:"/2018-03-17-yi-zhong-qian-hou-duan-fen-li-de-kua-yu-kai-fa-fang-shi/"},frontmatter:{title:"一种方便的跨域开发解决方案"}}},{node:{fields:{slug:"/2018-03-16-yuan-chuang-ji-yu-babylonjs-shi-xian-3d-da-ji-xiao-guo/"},frontmatter:{title:"基于 Babylon.js 实现 3D 打击效果"}}},{node:{fields:{slug:"/2018-03-13-fan-yi-ru-he-chuang-jian-jiao-hu-you-hao-de-biao-dan/"},frontmatter:{title:"【译】如何创建交互友好的表单"}}},{node:{fields:{slug:"/2018-03-12-fan-yi-rang-wo-men-cong-ling-kai-shi-bian-bian-xie-yi-ge-web-fu-wu-qi/"},frontmatter:{title:"【译】让我们从零开始编写一个web服务器"}}},{node:{fields:{slug:"/2018-03-11-bikeshedding/"},frontmatter:{title:"由屎色自行车棚引发的思考"}}},{node:{fields:{slug:"/2018-03-11-xin-shou-shi-jiao-de-docker/"},frontmatter:{title:"新手视角的 Docker"}}},{node:{fields:{slug:"/2018-03-07-fan-yi-ji-yu-cypress-ce-shi-react-ying-yong/"},frontmatter:{title:"【译】基于 Cypress 测试 React 应用"}}},{node:{fields:{slug:"/2018-03-05-fan-yi-ru-he-zhao-dao-wan-mei-de-se-cai-da-pei-jie-shao-colorclaim/"},frontmatter:{title:"【译】如何找到完美的色彩搭配 - 介绍 ColorClaim"}}},{node:{fields:{slug:"/2018-03-05-ru-he-shi-yong-mac-po-jie-wifi/"},frontmatter:{title:"如何使用Mac破解Wifi"}}},{node:{fields:{slug:"/2018-03-05-yi-ge-chrome-kuo-zhan-jiu-zhe-yang-dan-sheng-liao/"},frontmatter:{title:"程序员偷懒指南——用chrome插件实现前端资讯推送"}}},{node:{fields:{slug:"/2018-03-01-wei-xian-de-targetblank-yu-opener/"},frontmatter:{title:'危险的 target="_blank" 与 “opener”'}}},{node:{fields:{slug:"/2018-02-28-activerecord-he-datamappers-mo-shi-jian-jie/"},frontmatter:{title:"Active Record 和 Data Mappers 模式简介"}}},{node:{fields:{slug:"/2018-02-26-bu-jin-jin-shi-piao-liang-tu-xiang-ru-he-qu-dong-yong-hu-ti-yan/"},frontmatter:{title:"【译】不仅仅是漂亮：图像如何驱动用户体验"}}},{node:{fields:{slug:"/2018-02-23-css3-clip-path-yong-fa-jie-shao/"},frontmatter:{title:"CSS3 clip-path 用法介绍"}}},{node:{fields:{slug:"/2018-02-23-du-shu-bi-ji-ke-shi-hua-shi-yi-zhong-yi-shu-bu-zhi-shi-mei-xin-xi-tu-biao-she-ji-yuan-li-yu-jing-dian-an-li-xu-zhang/"},frontmatter:{title:"读书笔记：可视化是一种艺术 -《不只是美：信息图表设计原理与经典案例》序章"}}},{node:{fields:{slug:"/2018-02-23-mei-ge-node-ying-yong-ke-neng-cun-zai-de-timing-attack-an-quan-lou-dong/"},frontmatter:{title:"每个 node 应用可能存在的 timing-attack 安全漏洞"}}},{node:{fields:{slug:"/2018-02-09-zan-lai-liao-liao-vuecompile/"},frontmatter:{title:"咱来聊聊 Vue - compile"}}},{node:{fields:{slug:"/2018-02-05-ji-yi-ci-jian-dan-de-csrf-gong-ji-shi-yan/"},frontmatter:{title:"记一次简单的 CSRF 攻击实验"}}},{node:{fields:{slug:"/2018-02-04-fan-yi-reactscope-jie-shao/"},frontmatter:{title:"【译】React Scope介绍"}}},{node:{fields:{slug:"/2018-02-03-fan-yi-liu-ge-xuan-ze-ui-yan-se-de-ji-qiao/"},frontmatter:{title:"【译】六个选择UI颜色的技巧"}}},{node:{fields:{slug:"/2018-02-03-huo-yong-git-apply-he-ru-patch-bu-ding/"},frontmatter:{title:"活用 git apply 合入 patch 补丁"}}},{node:{fields:{slug:"/2018-02-03-wo-de-di-yi-ge-node-ming-ling-hang-gong-ju/"},frontmatter:{title:"我的第一个 Node 命令行工具"}}},{node:{fields:{slug:"/2018-02-01-fan-yi-react-xin-de-contextapi/"},frontmatter:{title:"【译】React ⚛️  新的 Context API"}}},{node:{fields:{slug:"/2018-01-29-kuai-su-da-jian-ni-de-github-page-ge-ren-bo-ke-ji-yu-createreactapp-de-dan-ye-mian-ying-yong-shi-jian/"},frontmatter:{title:"快速搭建你的 github pages 个人博客 —— 基于 Create-React-App 的单页面应用实践"}}},{node:{fields:{slug:"/2018-01-28-redux-promise-middleware/"},frontmatter:{title:"一个插件让你在 Redux 中写 promise 事半功倍"}}},{node:{fields:{slug:"/2018-01-28-fan-yi-react-zu-jian-mo-shi/"},frontmatter:{title:"【译】React 组件设计模式基础"}}},{node:{fields:{slug:"/2018-01-28-fan-yi-bu-yao-rang-yong-hu-zai-chan-pin-ti-yan-shang-shou-dao-cuo-zhe/"},frontmatter:{title:"【译】不要让用户在产品体验上受到挫折"}}},{node:{fields:{slug:"/2018-01-27-javascript-mo-huan-dai-li/"},frontmatter:{title:"JavaScript 魔幻代理"}}},{node:{fields:{slug:"/2018-01-22-web-qian-duan-jian-dan-ding-yue-de-shi-xian/"},frontmatter:{title:"Web前端简单订阅的实现"}}},{node:{fields:{slug:"/2018-01-21-how-django-works/"},frontmatter:{title:"从请求到响应 django 都做了哪些处理"}}},{node:{fields:{slug:"/2018-01-21-electron-with-react/"},frontmatter:{title:"React+Electron搭建一个桌面应用"}}},{node:{fields:{slug:"/2018-01-20-fan-yi-ui-she-ji-zhong-de-ge-shi-ta-yuan-ze/"},frontmatter:{title:"【译】UI 设计中的格式塔原则"}}},{node:{fields:{slug:"/2018-01-19-xia-yi-dai-tong-xin-xie-yi-quic/"},frontmatter:{title:"下一代通信协议：QUIC"}}},{node:{fields:{slug:"/2018-01-19-fan-yi-shi-yong-css-zhui-zong-yong-hu/"},frontmatter:{title:"【译】使用 CSS 追踪用户"}}},{node:{fields:{slug:"/2018-01-14-antd-yuan-ma-jie-du-notification/"},frontmatter:{title:"antd 源码解读 notification"}}},{node:{fields:{slug:"/2018-01-14-ui-zhong-de-pai-ban-chu-xue-zhe-zhi-nan/"},frontmatter:{title:"【译】UI 中的排版：初学者指南"}}},{node:{fields:{slug:"/2018-01-14-learn-koa-intro/"},frontmatter:{title:"koa包教包会(一)——白话koa"}}},{node:{fields:{slug:"/2018-01-13-zi-ji-dong-shou-xie-yi-ge-simplevue/"},frontmatter:{title:"自己动手写一个 SimpleVue"}}},{node:{fields:{slug:"/2018-01-12-translation-React-Animations-in-Depth/"},frontmatter:{title:"【译】React Web 动画的 5 种创建方式，每一种都不简单"}}},{node:{fields:{slug:"/2018-01-10-ru-he-kuo-zhan-create-react-app-de-webpack-pei-zhi/"},frontmatter:{title:"如何扩展 Create React App 的 Webpack 配置"}}},{node:{fields:{slug:"/2018-01-08-mapbox-gl-js/"},frontmatter:{title:"3D GIS 应用开发 —— 基于 Mapbox GL 的实践总结"}}},{node:{fields:{slug:"/2018-01-07-the-importance-of-visual-appeal-in-web-design/"},frontmatter:{title:"【译】视觉吸引力在网页设计中的重要性"}}},{node:{fields:{slug:"/2018-01-06-react-higher-order-component/"},frontmatter:{title:"React 高阶组件介绍"}}},{node:{fields:{slug:"/2018-01-05-to-vim/"},frontmatter:{title:"如何让 vim 成为我们的神器"}}},{node:{fields:{slug:"/2018-01-05-d3-js-v3-data-driven-and-d3-force/"},frontmatter:{title:"D3.js 数据驱动 和 force 力学图讲解"}}},{node:{fields:{slug:"/2018-01-05-create-a-redux-middleware/"},frontmatter:{title:"如何编写一个 Redux 中间件"}}}]}},pathContext:{slug:"/2018-10-23-reactfiber/"}}}});
//# sourceMappingURL=path---2018-10-23-reactfiber-1d33fd6677fe1fe2b381.js.map